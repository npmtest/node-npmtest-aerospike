{"/home/travis/build/npmtest/node-npmtest-aerospike/test.js":"/* istanbul instrument in package npmtest_aerospike */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-aerospike/lib.npmtest_aerospike.js":"/* istanbul instrument in package npmtest_aerospike */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_aerospike = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_aerospike = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-aerospike/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-aerospike && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_aerospike */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_aerospike\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_aerospike.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_aerospike.rollup.js'] =\n            local.assetsDict['/assets.npmtest_aerospike.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_aerospike.__dirname + '/lib.npmtest_aerospike.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/aerospike.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n/**\n * @module aerospike\n *\n * @description The Aerospike module is the main entry point for the Aerospike\n * Node.js Client API. It provides methods for creating new client instances\n * that connect to a specific Aerospike server cluster.\n *\n * # Data Model\n *\n * ## Record\n *\n * A record is how the data is represented and stored in the database. A record\n * is represented as an object. The keys of the object are the names of the fields\n * (bins) of a record. The values for each field can either be Number, String,\n * Array, Buffer or an Object itself. Aerospike supports integer, double,\n * string, bytes, array and map data types.\n *\n * Note: Array can contain an array or an object as a value in it. Similarly\n * the object can contain an array or an object as a value in it. Essentially\n * nesting of arrays in an object, and nesting of objects in an array is\n * allowed.\n *\n * Example of a record with 5 fields:\n *\n * ```js\n * var record = {\n *   int_bin: 123,\n *   str_bin: 'xyz',\n *   buff_bin: new Buffer('hello world!'),\n *   arr_bin: [1, 2, 3],\n *   obj_bin: {num: 123, str: 'abc', buff: new Buffer([0xa, 0xb, 0xc])}\n * }\n * ```\n *\n * ### Unsupported Data Types\n *\n * Aerospike does currently not support a boolean data type. To store boolean\n * values in the database the application needs to convert them to a supported\n * data type as the client does not do any automatica data type conversions.\n * Attempting to store a boolean value in a record bin will lead to a parameter\n * error being returned by the client.\n *\n * ## Metadata\n *\n * Some operations allow you to provide metadata with a record, including:\n *\n * - `gen` – (optional) The generation (version) of the record. Must be an Integer.\n * - `ttl` – (optional) The time-to-live in seconds (expiration) of the record.\n *   Must be an Integer. There are a few \"special\" TTL values which are defined\n *   under the {@link module:aerospike.ttl|ttl} property on the aerospike module.\n *\n * Example:\n *\n * ```js\n * var metadata = {\n *   gen: 1,\n *   ttl: 6000\n * }\n * ```\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const Key = Aerospike.Key\n *\n * const config = {\n *   hosts: '192.168.0.1:3000',\n *   policies: {\n *     timeout: 50\n *   }\n * }\n *\n * Aerospike.connect(config, (error, client) => {\n *   if (error) throw error\n *   var key = new Key('test', 'demo', 'key1')\n *   client.get(key, (error, record, meta) => {\n *     if (error) {\n *       switch (error.code) {\n *         case Aerospike.status.AEROSPIKE_ERR_RECORD_NOT_FOUND:\n *           console.error('record ' + key.key + ' does not exist')\n *           break;\n *         default:\n *           throw error\n *       }\n *     } else {\n *       console.log(record, meta)\n *     }\n *     client.close()\n *   })\n * })\n */\n\nconst as = require('../build/Release/aerospike.node')\n\nconst AerospikeError = require('./aerospike_error')\nconst Client = require('./client')\nconst Double = require('./double')\nconst GeoJSON = require('./geojson')\nconst Key = require('./key')\nconst asEventLoop = require('./event_loop')\nconst filter = require('./filter')\nconst info = require('./info')\nconst lists = require('./lists')\nconst maps = require('./maps')\nconst operations = require('./operations')\nconst utils = require('./utils')\n\n// copy maps related enums into maps module\nObject.keys(as.maps).forEach(function (key) {\n  maps[key] = as.maps[key]\n})\n\n/**\n * @function module:aerospike.client\n *\n * @summary Creates a new {@link Client} instance.\n *\n * @param {Config} config - The configuration for the client.\n */\nfunction client (config) {\n  return new Client(config)\n}\n\n/**\n * @function module:aerospike.connect\n *\n * @summary Creates a new {@link Client} instance and connects to the Aerospike cluster.\n *\n * @param {Config} [config] - The configuration for the client.\n * @param {Client~connectCallback} callback - The funcation to call, once the client is connected to the cluster successfully.\n */\nfunction connect (config, callback) {\n  if (typeof config === 'function') {\n    callback = config\n    config = null\n  }\n  var client = this.client(config)\n  client.connect(callback)\n  return client\n}\n\n/**\n * @function module:aerospike.key\n *\n * @summary Creates a new {@link Key} instance.\n *\n * @description Provided for backward compatibility. Use the {@link Key} class\n * constructor instead.\n *\n * @param {string} ns - The Namespace to which the key belongs.\n * @param {string} set - The Set to which the key belongs.\n * @param {(string|number|Buffer)} value - The unique key value. Keys can be\n * strings, integers or an instance of the Buffer class.\n *\n * @deprecated in v2.0\n */\nfunction key (ns, set, key) {\n  return new Key(ns, set, key)\n}\n\nfunction Aerospike () {\n  // classes && data types\n  this.Client = Client\n  this.AerospikeError = AerospikeError\n  this.Double = Double\n  this.GeoJSON = GeoJSON\n  this.Key = Key\n\n  // top-level methods exposed through Aerospike module\n  this.client = client\n  this.connect = connect\n  this.key = key\n  this.print = utils.print\n\n  this.releaseEventLoop = asEventLoop.releaseEventLoop\n\n  // other commands contained in sub-modules\n  this.filter = filter\n  this.info = info\n  this.lists = lists\n  this.maps = maps\n  this.operations = operations\n\n  // Include both scalar and list operations in the Aerospike.operator\n  // namespace for backwards compatibility. Aerospike.operator is deprecated\n  // and will be removed in the next major release.\n  var operator = {}\n  Object.keys(operations).forEach(function (key) {\n    operator[key] = operations[key]\n  })\n  Object.keys(lists).forEach(function (key) {\n    var listKey = 'list' + key.substr(0, 1).toUpperCase() + key.substr(1)\n    operator[listKey] = lists[key]\n  })\n  this.operator = operator\n\n  // enums imported from C client library\n\n  /**\n   * Enumeration of UDF types.\n   *\n   * @member {Object} language\n   * @readonly\n   * @static\n   *\n   * @property LUA - Lua (only supported UDF type at the moment)\n   */\n  this.language = as.language\n\n  /**\n   * Enumeration of log levels\n   *\n   * @member {Object} log\n   * @readonly\n   * @static\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   *\n   * var config = {\n   *   log: { level: Aerospike.log.INFO }\n   * }\n   * Aerospike.connect(config, (error, client) => {\n   *   if (error) throw error\n   *\n   *   var key = new Aerospike.Key('test', 'demo', 'k1')\n   *   client.get(key, (error, record) => {\n   *     if (error) throw error\n   *     console.info(record)\n   *     client.close()\n   *   })\n   * })\n   *\n   * @property OFF\n   * @property ERROR\n   * @property WARN\n   * @property DEBUG\n   * @property DETAIL\n   */\n  this.log = as.log\n\n  /**\n   * Enumeration of policy values.\n   *\n   * @member {Object} policy\n   * @readonly\n   * @static\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   *\n   * // global policy, applied to all commands that do not override it\n   * var config = {\n   *   policies: {\n   *     timeout: 100,\n   *     retry: Aerospike.policy.retry.ONCE\n   *   }\n   * }\n   *\n   * Aerospike.connect(config, (error, client) => {\n   *   if (error) throw error\n   *\n   *   var key = new Aerospike.Key('test', 'demo', 'k1')\n   *   var record = {i: 1234}\n   *\n   *   // override policy for put command\n   *   var policy = {\n   *     exists: Aerospike.policy.exists.CREATE,\n   *     key: Aerospike.policy.key.SEND\n   *   }\n   *\n   *   client.put(key, record, {}, policy, (error) => {\n   *     if (error && error.code === Aerospike.status.AEROSPIKE_ERR_RECORD_EXISTS) {\n   *       console.info('record already exists')\n   *     } else if (error) {\n   *       throw error\n   *     }\n   *     client.close()\n   *   })\n   * })\n   *\n   * @property {object} retry - Retry Policy - Specifies the behavior of failed\n   * operations. **Important**: Single key read/write commands, the\n   * batch read command and query/scan commands **do not follow** the retry\n   * policy. Retry policy is deprecated in v2.4 and will be removed\n   * in a future version.\n   *\n   * @property retry.NONE - Only attempt an operation once.\n   * @property retry.ONCE - If an operation fails, attempt the operation one\n   * more time.\n   *\n   * @property {object} gen - Generation Policy - Specifies the behavior of\n   * record modifications with regard to the generation value.\n   *\n   * @property gen.IGNORE - Write a record, regardless of generation.\n   * @property gen.EQ - Write a record, ONLY if generations are equal.\n   * @property gen.GT - Write a record, ONLY if local generation is greater than\n   * remote generation.\n   *\n   * @property {object} key - Key Policy - Specifies the behavior for whether\n   * keys or digests should be sent to the cluster.\n   *\n   * @property key.DIGEST - Send the digest value of the key. This is the\n   * recommended mode of operation. This calculates the digest and sends the\n   * digest to the server. The digest is only calculated on the client, and not\n   * the server.\n   *\n   * @property key.SEND - Send the key, in addition to the digest value. If you\n   * want keys to be returned when scanning or querying, the keys must be\n   * stored on the server. This policy causes a write operation to store the\n   * key. Once the key is stored, the server will keep it - there is no need to\n   * use this policy on subsequent updates of the record. If this policy is\n   * used on read or delete operations, or on subsequent updates of a record\n   * with a stored key, the key sent will be compared with the key stored on\n  * the server. A mismatch will cause\n  * <code>AEROSPIKE_ERR_RECORD_KEY_MISMATCH</code> to be returned.\n   *\n   * @property {object} exists - Existence Policy - Specifies the behavior for\n   * writing the record depending whether or not it exists.\n   *\n   * @property exists.IGNORE - Write the record, regardless of existence.\n   * (I.e. create or update.)\n   * @property exists.CREATE - Create a record, ONLY if it doesn't exist.\n   * @property exists.UPDATE - Update a record, ONLY if it exists.\n   * @property exists.REPLACE - Completely replace a record, ONLY if it exists.\n   * @property exists.CREATE_OR_REPLACE - Completely replace a record if it\n   * exists, otherwise create it.\n   *\n   * @property {object} replica - Specifies which partition replica to read from.\n   *\n   * @property replica.MASTER - Read from the partition master replica node.\n   * @property replica.ANY - Distribute reads across nodes containing key's\n   * master and replicated partition in round-robin fashion. Currently\n   * restricted to master and one prole.\n   *\n   * @property {object} consistencyLevel - Specifies the number of replicas to\n   * be consulted in a read operation to provide the desired consistency\n   * guarantee.\n   *\n   * @property consistencyLevel.ONE - Involve a single replica in the\n   * operation.\n   * @property consistencyLevel.ALL - Involve all replicas in the operation.\n   *\n   * @property {object} commitLevel - Specifies the number of replicas required\n   * to be successfully committed before returning success in a write operation\n   * to provide the desired consistency guarantee.\n   *\n   * @property commitLevel.ALL - Return success only after successfully\n   * committing all replicas.\n   * @property commitLevel.MASTER - Return success after successfully\n   * committing the master replica.\n   */\n  this.policy = as.policy\n\n  /**\n   * @summary Enumertion of special TTL (time-to-live) values.\n   *\n   * @description Instead of specifying a TTL in seconds, you can set the TTL\n   * to one of these special values when creating or updating a record.\n   *\n   * @member {Object} ttl\n   * @readonly\n   * @static\n   *\n   * @property NAMESPACE_DEFAULT - Use the default TTL value for the namespace of the record.\n   * @property NEVER_EXIRE - Never expire the record.\n   * @property DONT_UPDATE - Update the record without changing the record's\n   *                         TTL value. Requires Aerospike Server version 3.10.1 or later.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const Key = Aerospike.Key\n   *\n   * Aerospike.connect((error, client) => {\n   *   if (error) throw error\n   *   var key = new Key('test', 'demo', 'key1')\n   *   var record = { 'a': 1, 'b': 2 }\n   *   var meta = { ttl: 12345 }\n   *   var policy = { exists: Aerospike.policy.exists.CREATE_OR_REPLACE }\n   *   client.put(key, record, meta, policy, (error) => {\n   *     if (error) throw error\n   *     client.put(key, { c: 3 }, { ttl: Aerospike.ttl.DONT_UPDATE }, (error) => {\n   *       if (error) throw error\n   *       client.get(key, (error, record, meta) => {\n   *         if (error) throw error\n   *         console.log(record, meta) // => { a: 1, b: 2, c: 3 } { ttl: 12345, gen: 2 }\n   *         client.close()\n   *       })\n   *     })\n   *   })\n   * })\n   */\n  this.ttl = as.ttl\n\n  /**\n   * Enumeration of predicate types.\n   * @private\n   */\n  this.predicates = as.predicates\n\n  /**\n   * Enumeration of job status codes.\n   *\n   * @member {Object} jobStatus\n   * @readonly\n   * @static\n   *\n   * @see {@link Job#infoCallback} returns the job status.\n   *\n   * @property UNDEF - The job status is undefined. This is likely due to the\n   * status not being properly checked.\n   * @property INPROGRESS - The job is currently running.\n   * @property COMPLETED - The job completed successfully.\n   */\n  this.jobStatus = as.jobStatus\n\n  /**\n   * Enumeration of priority levels for a scan operation.\n   *\n   * @member {Object} scanPriority\n   * @readonly\n   * @static\n   *\n   *\n   * @see {@link Scan#priority}\n   *\n   * @property AUTO - The cluster will auto adjust the scan priority.\n   * @property LOW - Low scan priority.\n   * @property MEDIUM - Medium scan priority.\n   * @property HIGH - High scan priority.\n   */\n  this.scanPriority = as.scanPriority\n\n  /**\n   * Enumeration of secondary index data types.\n   *\n   * @member {Object} indexDataType\n   * @readonly\n   * @static\n   *\n   * @property STRING - Values contained in the secondary index are strings.\n   * @property NUMERIC - Values contained in the secondary index are integers.\n   * @property GEO2DSPHERE - Values contained in the secondary index are GeoJSON values (points or polygons).\n   *\n   * @see {@link Client#createIndex}\n   */\n  this.indexDataType = as.indexDataType\n\n  /**\n   * Enumeration of secondary index types.\n   *\n   * @member {Object} indexType\n   * @readonly\n   * @static\n   *\n   * @property DEFAULT - Default secondary index type for bins containing scalar values (i.e. integer, string).\n   *\n   * @property LIST - Secondary index for bins containing\n   * <a href=\"http://www.aerospike.com/docs/guide/cdt-list.html\" title=\"Aerospike List Data Type\">&uArr;Lists</a>;\n   * the index will be build over the individual entries of the list.\n   *\n   * @property MAPKEYS - Secondary index for bins containing\n   * <a href=\"http://www.aerospike.com/docs/guide/cdt-map.html\" title=\"Aerospike Maps Data Type\">&uArr;Maps</a>;\n   * the index will be build over the individual keys of the map entries.\n   *\n   * @property MAPVALUES - Secondary index for bins containing\n   * <a href=\"http://www.aerospike.com/docs/guide/cdt-map.html\" title=\"Aerospike Maps Data Type\">&uArr;Maps</a>;\n   * the index will be build over the individual values of the map entries.\n   *\n   * @see {@link Client#createIndex}\n   */\n  this.indexType = as.indexType\n\n  /**\n   * Enumeration of error status codes.\n   *\n   * @member {Object} status\n   * @readonly\n   * @static\n   *\n   * @property AEROSPIKE_ERR_INVALID_NODE - Node invalid or could not be found.\n   * @property AEROSPIKE_ERR_NO_MORE_CONNECTIONS - Asynchronous connection error.\n   * @property AEROSPIKE_ERR_ASYNC_CONNECTION - Asynchronous connection error.\n   * @property AEROSPIKE_ERR_CLIENT_ABORT - Query or scan was aborted in user's callback.\n   * @property AEROSPIKE_ERR_INVALID_HOST - Host name could not be found in DNS lookup.\n   * @property AEROSPIKE_NO_MORE_RECORDS - No more records available when parsing batch, scan or query records.\n   * @property AEROSPIKE_ERR_PARAM - Invalid client API parameter.\n   * @property AEROSPIKE_ERR_CLIENT - Generic client API usage error.\n   * @property AEROSPIKE_ERR - Generic client error (deprecated).\n   * @property AEROSPIKE_OK - Generic success.\n   * @property AEROSPIKE_ERR_SERVER - Generic error returned by the server.\n   * @property AEROSPIKE_ERR_RECORD_NOT_FOUND - Record does not exist in database. May be returned by read, or write with policy <code>exists: Aerospike.policy.exists.UPDATE</code>\n   * @property AEROSPIKE_ERR_RECORD_GENERATION - Generation of record in database does not satisfy write policy.\n   * @property AEROSPIKE_ERR_REQUEST_INVALID - Request protocol invalid, or invalid protocol field.\n   * @property AEROSPIKE_ERR_RECORD_EXISTS - Record already exists. May be returned by write with policy <code>exists: Aerospike.policy.exists.CREATE</code>.\n   * @property AEROSPIKE_ERR_BIN_EXISTS - Bin already exists.\n   * @property AEROSPIKE_ERR_CLUSTER_CHANGE - A cluster state change occurred during the request.\n   * @property AEROSPIKE_ERR_SERVER_FULL - The server node is running out of memory and/or storage device space reserved for the specified namespace.\n   * @property AEROSPIKE_ERR_TIMEOUT - Request timed out. Can be triggered by client or server.\n   * @property AEROSPIKE_ERR_NO_XDR - XDR not available for the cluster.\n   * @property AEROSPIKE_ERR_CLUSTER - Generic cluster discovery & connection error.\n   * @property AEROSPIKE_ERR_BIN_INCOMPATIBLE_TYPE - Bin modification operation cannot be done on an existing bin due to its value type.\n   * @property AEROSPIKE_ERR_RECORD_TOO_BIG - Record being (re-)written cannot fit in a storage write block.\n   * @property AEROSPIKE_ERR_RECORD_BUSY - Too many concurrent requests for one record - a \"hot key\" situation.\n   * @property AEROSPIKE_ERR_SCAN_ABORTED - Scan aborted by user.\n   * @property AEROSPIKE_ERR_UNSUPPORTED_FEATURE - Sometimes our doc, or our customers' wishes, get ahead of us. We may have processed something that the server is not ready for (unsupported feature).\n   * @property AEROSPIKE_ERR_BIN_NOT_FOUND - Bin-level replace-only supported on server but not on client.\n   * @property AEROSPIKE_ERR_DEVICE_OVERLOAD - The server node's storage device(s) can't keep up with the write load.\n   * @property AEROSPIKE_ERR_RECORD_KEY_MISMATCH - Record key sent with transaction did not match key stored on server.\n   * @property AEROSPIKE_ERR_NAMESPACE_NOT_FOUND - Namespace in request not found on server.\n   * @property AEROSPIKE_ERR_BIN_NAME - Sent too-long bin name or exceeded namespace's bin name quota.\n   * @property AEROSPIKE_ERR_FAIL_FORBIDDEN - Operation not allowed at this time.\n   * @property AEROSPIKE_QUERY_END - There are no more records left for query.\n   * @property AEROSPIKE_SECURITY_NOT_SUPPORTED - Security functionality not supported by connected server.\n   * @property AEROSPIKE_SECURITY_NOT_ENABLED - Security functionality not enabled by connected server.\n   * @property AEROSPIKE_SECURITY_SCHEME_NOT_SUPPORTED - Security type not supported by connected server.\n   * @property AEROSPIKE_INVALID_COMMAND - Administration command is invalid.\n   * @property AEROSPIKE_INVALID_FIELD - Administration field is invalid.\n   * @property AEROSPIKE_ILLEGAL_STATE - Security protocol not followed.\n   * @property AEROSPIKE_INVALID_USER - User name is invalid.\n   * @property AEROSPIKE_USER_ALREADY_EXISTS - User was previously created.\n   * @property AEROSPIKE_INVALID_PASSWORD - Password is invalid.\n   * @property AEROSPIKE_EXPIRED_PASSWORD - Password has expired.\n   * @property AEROSPIKE_FORBIDDEN_PASSWORD - Forbidden password (e.g. recently used).\n   * @property AEROSPIKE_INVALID_CREDENTIAL - Security credential is invalid.\n   * @property AEROSPIKE_INVALID_ROLE - Role name is invalid.\n   * @property AEROSPIKE_ROLE_ALREADY_EXISTS - Role name already exists.\n   * @property AEROSPIKE_INVALID_PRIVILEGE - Privilege is invalid.\n   * @property AEROSPIKE_NOT_AUTHENTICATED - User must be authenticated before performing database operations.\n   * @property AEROSPIKE_ROLE_VIOLATION - User does not possess the required role to perform the database operation.\n   * @property AEROSPIKE_ERR_UDF - Generic UDF error.\n   * @property AEROSPIKE_ERR_LARGE_ITEM_NOT_FOUND - The requested item in a large collection was not found.\n   * @property AEROSPIKE_ERR_BATCH_DISABLED - Batch functionality has been disabled.\n   * @property AEROSPIKE_ERR_BATCH_MAX_REQUESTS_EXCEEDED - Batch max. requests have been exceeded.\n   * @property AEROSPIKE_ERR_BATCH_QUEUES_FULL - All batch queues are full.\n   * @property AEROSPIKE_ERR_GEO_INVALID_GEOJSON - Invalid/unsupported GeoJSON.\n   * @property AEROSPIKE_ERR_INDEX_FOUND - Index found.\n   * @property AEROSPIKE_ERR_INDEX_NOT_FOUND - Index not found.\n   * @property AEROSPIKE_ERR_INDEX_OOM - Index is out of memory.\n   * @property AEROSPIKE_ERR_INDEX_NOT_READABLE - Unable to read the index.\n   * @property AEROSPIKE_ERR_INDEX - Generic secondary index error.\n   * @property AEROSPIKE_ERR_INDEX_NAME_MAXLEN - Index name is too long.\n   * @property AEROSPIKE_ERR_INDEX_MAXCOUNT - System alrady has maximum allowed indeces.\n   * @property AEROSPIKE_ERR_QUERY_ABORTED - Query was aborted.\n   * @property AEROSPIKE_ERR_QUERY_QUEUE_FULL - Query processing queue is full.\n   * @property AEROSPIKE_ERR_QUERY_TIMEOUT - Secondary index query timed out on server.\n   * @property AEROSPIKE_ERR_QUERY - Generic query error.\n   * @property AEROSPIKE_ERR_UDF_NOT_FOUND - UDF does not exist.\n   * @property AEROSPIKE_ERR_LUA_FILE_NOT_FOUND - LUA file does not exist.\n   * @property AEROSPIKE_ERR_LDT_INTERNAL - Internal LDT error.\n   * @property AEROSPIKE_ERR_LDT_NOT_FOUND - LDT item not found.\n   * @property AEROSPIKE_ERR_LDT_UNIQUE_KEY - Unique key violation: Duplicated item inserted when 'unique key' was set.\n   * @property AEROSPIKE_ERR_LDT_INSERT - General error during insert operation.\n   * @property AEROSPIKE_ERR_LDT_SEARCH - General error during search operation.\n   * @property AEROSPIKE_ERR_LDT_DELETE - General error during delete operation.\n   * @property AEROSPIKE_ERR_LDT_INPUT_PARM - General input parameter error.\n   * @property AEROSPIKE_ERR_LDT_TYPE_MISMATCH - LDT type mismatch for this bin.\n   * @property AEROSPIKE_ERR_LDT_NULL_BIN_NAME - The supplied LDT bin name is null.\n   * @property AEROSPIKE_ERR_LDT_BIN_NAME_NOT_STRING - The supplied LDT bin name must be a string.\n   * @property AEROSPIKE_ERR_LDT_BIN_NAME_TOO_LONG - The supplied LDT bin name exceeded the 14 char limit.\n   * @property AEROSPIKE_ERR_LDT_TOO_MANY_OPEN_SUBRECS - Internal Error: too many open records at one time.\n   * @property AEROSPIKE_ERR_LDT_TOP_REC_NOT_FOUND - Internal Error: Top Record not found.\n   * @property AEROSPIKE_ERR_LDT_SUB_REC_NOT_FOUND - Internal Error: Sub Record not found.\n   * @property AEROSPIKE_ERR_LDT_BIN_DOES_NOT_EXIST - LDT Bin does not exist.\n   * @property AEROSPIKE_ERR_LDT_BIN_ALREADY_EXISTS - Collision: LDT Bin already exists.\n   * @property AEROSPIKE_ERR_LDT_BIN_DAMAGED - LDT control structures in the Top Record are damanged. Cannot proceed.\n   * @property AEROSPIKE_ERR_LDT_SUBREC_POOL_DAMAGED - Internal Error: LDT Subrecord pool is damanged.\n   * @property AEROSPIKE_ERR_LDT_SUBREC_DAMAGED - LDT control structure in the Sub Record are damaged. Cannot proceed.\n   * @property AEROSPIKE_ERR_LDT_SUBREC_OPEN - Error encountered while opening a Sub Record.\n   * @property AEROSPIKE_ERR_LDT_SUBREC_UPDATE - Error encountered while updating a Sub Record.\n   * @property AEROSPIKE_ERR_LDT_SUBREC_CREATE - Error encountered while creating a Sub Record.\n   * @property AEROSPIKE_ERR_LDT_SUBREC_DELETE - Error encountered while deleting a Sub Record.\n   * @property AEROSPIKE_ERR_LDT_SUBREC_CLOSE - Error encountered while closing a Sub Record.\n   * @property AEROSPIKE_ERR_LDT_TOPREC_UPDATE - Error encountered while updating a TOP Record.\n   * @property AEROSPIKE_ERR_LDT_TOPREC_CREATE - Error encountered while creating a TOP Record.\n   * @property AEROSPIKE_ERR_LDT_FILTER_FUNCTION_BAD - The filter function name was invalid.\n   * @property AEROSPIKE_ERR_LDT_FILTER_FUNCTION_NOT_FOUND - The filter function was not found.\n   * @property AEROSPIKE_ERR_LDT_KEY_FUNCTION_BAD - The function to extract the Unique Value from a complex object was invalid.\n   * @property AEROSPIKE_ERR_LDT_KEY_FUNCTION_NOT_FOUND - The function to extract the Unique Value from a complex object was not found.\n   * @property AEROSPIKE_ERR_LDT_TRANS_FUNCTION_BAD - The function to transform an object into a binary form was invalid.\n   * @property AEROSPIKE_ERR_LDT_TRANS_FUNCTION_NOT_FOUND - The function to transform an object into a binary form was not found.\n   * @property AEROSPIKE_ERR_LDT_UNTRANS_FUNCTION_BAD - The function to untransform an object from binary form to live form was invalid.\n   * @property AEROSPIKE_ERR_LDT_UNTRANS_FUNCTION_NOT_FOUND - The function to untransform an object from binary form to live form was not found.\n   * @property AEROSPIKE_ERR_LDT_USER_MODULE_BAD - The UDF user module name for LDT Overrides was invalid.\n   * @property AEROSPIKE_ERR_LDT_USER_MODULE_NOT_FOUND - The UDF user module name for LDT Overrides was not found.\n   *\n   * @see {@link AerospikeError#code}\n   */\n  this.status = as.status\n}\nmodule.exports = new Aerospike()\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/aerospike_error.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nconst util = require('util')\n\n/**\n * @class AerospikeError\n * @extends Error\n * @classdesc Error status returned by the server.\n *\n * @summary Construct a new AerospikeError instance.\n *\n * @param {number} code - The status code of the error.\n * @param {string} [message] - A message describing the status code.\n * @param {string} [func] - The name of the function in which the error occurred.\n * @param {string} [file] - The file name in which the error occurred.\n * @param {string} [line] - The line number on which the error occurred.\n *\n * @see <code>Aerospike.status</code> contains the full list of possible status codes.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * var key = new Aerospike.Key('test', 'key', 'does_not_exist')\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *   client.get(key, (error, record) => {\n *     console.log(error) // => { [AerospikeError: AEROSPIKE_ERR_RECORD_NOT_FOUND]\n *                        //      code: 2,\n *                        //      message: 'AEROSPIKE_ERR_RECORD_NOT_FOUND',\n *                        //      func: 'as_event_command_parse_result',\n *                        //      file: 'src/main/aerospike/as_event.c',\n *                        //      line: 614,\n *                        //      name: 'AerospikeError' }\n *   })\n *   client.close()\n * })\n */\nfunction AerospikeError (code, message, func, file, line, stack) {\n  /**\n   * Error name\n   *\n   * @name AerospikeError#name\n   * @type {string}\n   * @readonly\n   */\n  Object.defineProperty(this, 'name', {value: 'AerospikeError'})\n\n  /**\n   * Error message\n   *\n   * @name AerospikeError#message\n   * @type {string}\n   * @readonly\n   */\n  this.message = message || 'Aerospike Error'\n\n  /**\n   * Status code.\n   *\n   * @name AerospikeError#code\n   * @type {number}\n   * @readonly\n   *\n   * @see List of status codes defined at {@link module:aerospike.status}\n   */\n  this.code = code\n\n  /**\n   * C/C++ function name where the error occurred.\n   *\n   * @name AerospikeError#func\n   * @type {?string}\n   * @readonly\n   */\n  this.func = func\n\n  /**\n   * File name of the C/C++ source file in which the error occurred.\n   *\n   * @name AerospikeError#file\n   * @type {?string}\n   * @readonly\n   */\n  this.file = file\n\n  /**\n   * Line number in the C/C++ source file in which the error occurred.\n   *\n   * @name AerospikeError#file\n   * @type {?string}\n   * @readonly\n   */\n  this.line = line\n\n  if (stack) {\n    stack = stack.replace(/^.*$/m, util.format('%s: %s', this.name, this.message))\n    Object.defineProperty(this, 'stack', {value: stack})\n  } else {\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\nAerospikeError.fromASError = function (err) {\n  return new AerospikeError(err.code, err.message, err.func, err.file, err.line, err.stack)\n}\n\nutil.inherits(AerospikeError, Error)\n\nmodule.exports = AerospikeError\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/client.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nconst as = require('../build/Release/aerospike.node')\nconst AerospikeError = require('./aerospike_error')\nconst Config = require('./config')\nconst IndexJob = require('./index_job')\nconst LargeList = require('./llist')\nconst Query = require('./query')\nconst Scan = require('./scan')\nconst asEventLoop = require('./event_loop')\nconst operations = require('./operations')\nconst utils = require('./utils')\n\n// number of client instances currently connected to any Aerospike cluster\nvar _connectedClients = 0\n\n/**\n * @class Client\n * @classdesc Aerospike client\n *\n * @summary Construct a new Aerospike client instance.\n *\n * @param {Config} config - Configuration used to initialize the client.\n */\nfunction Client (config) {\n  if (asEventLoop.eventLoopReleased()) {\n    throw new Error('Event loop resources have already been released! Call Client#close() with releaseEventLoop set to false to avoid this error.')\n  }\n\n  /**\n   * @name Client#config\n   *\n   * @summary A copy of the configuration with which the client was initialized.\n   *\n   * @type {Config}\n   */\n  this.config = new Config(config)\n\n  /** @private */\n  this.as_client = as.client(this.config)\n\n  /** @private */\n  this.callbackHandler = Client.callbackHandler\n\n  /** @private */\n  this.connected = false\n\n  /** @private */\n  this.captureStackTraces = !!process.env.AEROSPIKE_DEBUG_STACKTRACES\n}\n\n// The callback functions for the client commands take a variable number of\n// arguments. Since use of the arguments variable can prevent V8 from\n// optimizing the function we declare the max. number of arguments statically.\n// See // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n// for more information.\nClient.DefaultCallbackHandler = function (callback, err, arg1, arg2, arg3) {\n  if (!callback) return\n  if (err && err.code !== as.status.AEROSPIKE_OK) {\n    var error = (err instanceof AerospikeError) ? err : AerospikeError.fromASError(err)\n    return callback(error)\n  } else {\n    return callback(null, arg1, arg2, arg3)\n  }\n}\n\nClient.LegacyCallbackHandler = function (callback, err, arg1, arg2, arg3) {\n  if (!callback) return\n  callback(err, arg1, arg2, arg3)\n}\n\nClient.callbackHandler = Client.DefaultCallbackHandler\n\nClient.setCallbackHandler = function (callbackHandler) {\n  this.callbackHandler = callbackHandler\n}\n\n/**\n * @function Client#LargeList\n *\n * @summary Creates a new LargeList instance, which is used to perform all LDT operations in the database.\n *\n * @param {Key} key - A key, used to locate the record in the cluster.\n * @param {string} binName - Name of the Large Data Type Bin.\n * @param {Client~WritePolicy} [writePolicy] - The Write Policy to use for this operation.\n * @param {string} [createModule] - Lua function name that initialized the list configuration parameters, pass null for default list.\n *\n * @deprecated since v2.4.4\n *\n * @see {@link LargeList}\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const Key = Aerospike.Key\n *\n * const key = new Key('test', 'demo', 'ldt_key')\n * const policy = { timeout: 1000 }\n *\n * Aerospike.connect((error, client) => {\n *   var llist = client.LargeList(key, 'ldtBinName', policy);\n *   llist.add('abc', (error) => {\n *     client.close()\n *   })\n * })\n */\nClient.prototype.LargeList = function (key, binName, policy, createModule) {\n  return new LargeList(this, key, binName, policy, createModule)\n}\n\n/**\n * @function Client#batchExists\n *\n * @summary Checks the existence of a batch of records from the database cluster.\n *\n * @param {Key[]} keys - An array of Keys used to locate the records in the cluster.\n * @param {Client~BatchPolicy} [policy] - The Batch Policy to use for this operation.\n * @param {Client~batchRecordsCallback} callback - The function to call when the operation completes, with the results of the batch operation.\n *\n * @deprecated since v2.0 - use {@link Client#batchRead} instead.\n *\n * @example\n *\n * var keys = [\n *   new Key('test', 'demo', 'key1'),\n *   new Key('test', 'demo', 'key2'),\n *   new Key('test', 'demo', 'key3')\n * ]\n *\n * client.batchExists(keys, function (error, results) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     results.forEach(function (result) {\n *       switch (result.status) {\n *         case status.AEROSPIKE_OK:\n *           // record found\n *           break\n *         case status.AEROSPIKE_ERR_RECORD_NOT_FOUND:\n *           // record not found\n *           break\n *         default:\n *           // error while reading record\n *           break\n *       }\n *     })\n *   }\n * })\n */\nClient.prototype.batchExists = function (keys, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  this.sendCommand('batchExists', [keys, policy], callback)\n}\n\n/**\n * @function Client#batchGet\n *\n * @summary Reads a batch of records from the database cluster.\n *\n * @param {Key[]} keys - An array of keys, used to locate the records in the cluster.\n * @param {Client~BatchPolicy} [policy] - The Batch Policy to use for this operation.\n * @param {Client~batchRecordsCallback} callback - The function to call when the operation completes, with the results of the batch operation.\n *\n * @deprecated since v2.0 - use {@link Client#batchRead} instead.\n *\n * @example\n *\n * var keys = [\n *   new Key('test', 'demo', 'key1'),\n *   new Key('test', 'demo', 'key2'),\n *   new Key('test', 'demo', 'key3')\n * ]\n *\n * client.batchGet(keys, function (error, results) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     results.forEach(function (result) {\n *       switch (result.status) {\n *         case status.AEROSPIKE_OK:\n *           // record found - bin values are available in result.record\n *           break\n *         case status.AEROSPIKE_ERR_RECORD_NOT_FOUND:\n *           // record not found\n *           break\n *         default:\n *           // error while reading record\n *           break\n *       }\n *     })\n *   }\n * })\n */\nClient.prototype.batchGet = function (keys, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  this.sendCommand('batchGet', [keys, policy], callback)\n}\n\n/**\n * @function Client#batchRead\n *\n * @summary Read multiple records for specified batch keys in one batch call.\n *\n * @description\n *\n * This method allows different namespaces/bins to be requested for each key in\n * the batch. This method requires Aerospike Server version >= 3.6.0.\n *\n * @param {object[]} records - List of keys and bins to retrieve.\n * @param {Key} records[].key - Key to retrieve.\n * @param {string[]} [records[].bins] - List of bins to retrieve.\n * @param {boolean} [records[].read_all_bins] - Whether to retrieve all bins or\n * just the meta data of the record. If true, ignore <code>bins</code> and read\n * all bins; if false and <code>bins</code> is specified, read specified bins;\n * if false and <code>bins</code> is not specified, read only record meta data\n * (generation, expiration, etc.)\n * @param {Client~BatchPolicy} [policy] - The Batch Policy to use for this operation.\n * @param {Client~batchRecordsCallback} callback - The function to call when the operation completes, with the results of the batch operation.\n *\n * @since v2.0\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * var batchRecords = [\n *   { key: new Aerospike.Key('test', 'demo', 'key1'), bins: ['i', 's'] },\n *   { key: new Aerospike.Key('test', 'demo', 'key2'), read_all_bins: true },\n *   { key: new Aerospike.Key('test', 'demo', 'key3') }\n * ]\n * Aerospike.connect(function (error, client) {\n *   if (error) throw error\n *   client.batchRead(batchRecords, function (error, results) {\n *     if (error) throw error\n *     results.forEach(function (result) {\n *       console.log(result)\n *     })\n *   })\n * })\n */\nClient.prototype.batchRead = function (records, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  this.sendCommand('batchRead', [records, policy], callback)\n}\n\n/**\n * @function Client#batchSelect\n *\n * @summary Reads a subset of bins for a batch of records from the database cluster.\n *\n * @param {Key[]} keys - An array of keys, used to locate the records in the cluster.\n * @param {string[]} bins - An array of bin names for the bins to be returned for the given keys.\n * @param {Client~BatchPolicy} [policy] - The Batch Policy to use for this operation.\n * @param {Client~batchRecordCallback} callback - The function to call when the operation completes, with the results of the batch operation.\n *\n * @deprecated since v2.0 - use {@link Client#batchRead} instead.\n *\n * @example\n *\n * var keys = [\n *   new Key('test', 'demo', 'key1'),\n *   new Key('test', 'demo', 'key2'),\n *   new Key('test', 'demo', 'key3')\n * ]\n * var bins = ['s', 'i']\n *\n * client.batchSelect(keys, bins, function (error, results) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     results.forEach(function (result) {\n *       switch (result.status) {\n *         case status.AEROSPIKE_OK:\n *           // record found - selected bins are available in result.record.\n *           break\n *         case status.AEROSPIKE_ERR_RECORD_NOT_FOUND:\n *           // record not found\n *           break\n *         default:\n *           // error while reading record\n *           break\n *       }\n *     })\n *   }\n * })\n */\nClient.prototype.batchSelect = function (keys, bins, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  this.sendCommand('batchSelect', [keys, bins, policy], callback)\n}\n\n/**\n * @function Client#close\n *\n * @summary Closes the client connection to the cluster.\n *\n * @param {boolean} [releaseEventLoop=true] - Whether to release the event loop handle after the client is closed.\n *\n * @see module:aerospike.releaseEventLoop\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * Aerospike.connect(function (error, client) {\n *   if (error) throw error\n *   // client ready to receive commands\n *   client.close()\n * })\n */\nClient.prototype.close = function (releaseEventLoop) {\n  if (typeof releaseEventLoop === 'undefined') {\n    releaseEventLoop = true\n  }\n  if (!this.isConnected(false)) return\n  this.connected = false\n  this.as_client.close()\n  _connectedClients -= 1\n  if (releaseEventLoop && _connectedClients === 0) {\n    asEventLoop.releaseEventLoop()\n  }\n}\n\n/**\n * @function Client#connect\n *\n * @summary Establishes the connection to the cluster.\n *\n * @description\n *\n * Once the client is connected to at least one server node, it will start\n * polling each cluster node regularly to discover the current cluster status.\n * As new nodes are added to the cluster, or existing nodes are removed, the\n * client will establish or close down connections to these nodes. If the\n * client gets disconnected from the cluster, it will keep polling the last\n * known server endpoints, and will reconnect automatically if the connection\n * is reestablished.\n *\n * It is recommended that you use the {@link module:aerospike.connect} method\n * to connect to the cluster. You will receive the client instance in the\n * {@link Client~connectCallback|connect callback} once the cluster connection\n * has been established and the client is ready to accept commands.\n *\n * @param {Client~connectCallback} callback - The function to call once the\n * client connection has been established successfully.\n *\n * @return {Client} Client object which was used to connect to the cluster.\n *\n * @see {@link Config#connTimeoutMs} - Initial host connection timeout in milliseconds.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n *\n * var config = { ... }\n * var client = Aerospike.client(config)\n * client.connect((error) => {\n *   if (error) {\n *     console.error('Failed to connect to cluster: %s', error.message)\n *     process.exit()\n *   } else {\n *     // client is ready to accept commands\n *   }\n * })\n */\nClient.prototype.connect = function (callback) {\n  var self = this\n  asEventLoop.registerASEventLoop()\n  this.as_client.connect(function connectCb (err) {\n    self.connected = (!err || err.code === as.status.AEROSPIKE_OK)\n    if (self.connected) {\n      _connectedClients += 1\n    } else {\n      self.as_client.close()\n    }\n    self.callbackHandler(callback, err, self)\n  })\n  return this\n}\n\n/**\n * @function Client#createIndex\n *\n * @summary Creates a secondary index.\n *\n * @description\n *\n * Calling the <code>createIndex</code> method issues an\n * index create command to the Aerospike cluster and returns immediately. To\n * verify that the index has been created and populated with all the data use\n * the {@link IndexJob} instance returned by the callback.\n *\n * Aerospike currently supports indexing of strings, integers and geospatial\n * information in GeoJSON format.\n *\n * ##### String Indexes\n *\n * A string index allows for equality lookups. An equality lookup means that if\n * you query for an indexed bin with value \"abc\", then only records containing\n * bins with \"abc\" will be returned.\n *\n * ##### Integer Indexes\n *\n * An integer index allows for either equality or range lookups. An equality\n * lookup means that if you query for an indexed bin with value 123, then only\n * records containing bins with the value 123 will be returned. A range lookup\n * means that if you can query bins within a range. So, if your range is\n * (1...100), then all records containing a value in that range will be\n * returned.\n *\n * ##### Geo 2D Sphere Indexes\n *\n * A geo 2d sphere index allows either \"contains\" or \"within\" lookups. A\n * \"contains\" lookup means that if you query for an indexed bin with GeoJSON\n * point element, then only records containing bins with a GeoJSON element\n * containing that point will be returned. A \"within\" lookup means that if you\n * query for an indexed bin with a GeoJSON polygon element, then all records\n * containing bins with a GeoJSON element wholly contained within that polygon\n * will be returned.\n *\n * @param {Object} options - Options for creating the index.\n * @param {string} options.ns - The namespace on which the index is to be created.\n * @param {string} options.set - The set on which the index is to be created.\n * @param {string} options.bin - The name of the bin which values are to be indexed.\n * @param {string} options.index - The name of the index to be created.\n * @param {module:aerospike.indexType} [options.type] - Type of index to be\n * created based on the type of values stored in the bin. This option needs to\n * be specified if the bin to be indexed contains list or map values and the\n * individual entries of the list or keys/values of the map should be indexed.\n * @param {module:aerospike.indexDataType} options.datatype - The data type of\n * the index to be created, e.g. Numeric, String or Geo.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~jobCallback} callback - The function to call when the operation completes.\n *\n * @see {@link module:aerospike.indexType} for enumeration of supported index types.\n * @see {@link module:aerospike.indexDataType} for enumeration of supported data types.\n * @see {@link IndexJob}\n *\n * @since v2.0\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *\n *   // create index over user's recent locations\n *   var namespace = 'test'\n *   var set = 'demo'\n *   var binName = 'rloc' // recent locations\n *   var indexName = 'recentLocationsIdx'\n *   var indexType = Aerospike.indexType.LIST\n *   var dataType = Aerospike.indexDataType.GEO2DSPHERE\n *   var options = { ns: namespace,\n *                   set: set,\n *                   bin: binName,\n *                   index: indexName,\n *                   type: indexType,\n *                   datatype: dataType }\n *   var policy = { timeout: 100 }\n *\n *   client.createIndex(options, policy, (error, job) => {\n *     if (error) throw error\n *\n *     // wait for index creation to complete\n *     var pollInterval = 100\n *     job.waitUntilDone(pollInterval, (error) => {\n *       if (error) throw error\n *       console.info('secondary index %s on %s was created successfully', indexName, binName)\n *       client.close()\n *     })\n *   })\n * })\n */\nClient.prototype.createIndex = function (options, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function')\n  }\n  var args = [\n    options.ns,\n    options.set,\n    options.bin,\n    options.index,\n    options.type || as.indexType.DEFAULT,\n    options.datatype,\n    policy || options.policy\n  ]\n  var self = this\n  this.sendCommand('indexCreate', args, function (err) {\n    var job = new IndexJob(self, options.ns, options.index)\n    callback(err, job)\n  })\n}\n\n/**\n * @function Client#createIntegerIndex\n *\n * @summary Creates a secondary index of type Integer.\n *\n * @description This is a short-hand for calling {@link Client#createIndex}\n * with the <code>datatype</code> option set to <code>Aerospike.indexDataType.NUMERIC</code>.\n *\n * @param {Object} options - Options for creating the index.\n * @param {string} options.ns - The namespace on which the index is to be created.\n * @param {string} options.set - The set on which the index is to be created.\n * @param {string} options.bin - The name of the bin which values are to be indexed.\n * @param {string} options.index - The name of the index to be created.\n * @param {module:aerospike.indexType} [options.type] - Type of index to be\n * created based on the type of values stored in the bin. This option needs to\n * be specified if the bin to be indexed contains list or map values and the\n * individual entries of the list or keys/values of the map should be indexed.\n * @param {Client~InfoPolicy} [options.policy] - Deprecated - set policy using\n * <code>policy</code> parameter instead.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~jobCallback} callback - The function to call when the operation completes.\n *\n * @see {@link Client#indexCreate}\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *\n *   var binName = 'age'\n *   var indexName = 'ageIndex'\n *   var options = { ns: 'test',\n *                   set: 'demo',\n *                   bin: binName,\n *                   index: indexName }\n *\n *   client.createIntegerIndex(options, function (error) {\n *     if (error) throw error\n *     console.info('secondary index %s on %s was created successfully', indexName, binName)\n *     client.close()\n *   })\n * })\n */\nClient.prototype.createIntegerIndex = function (options, policy, callback) {\n  options.datatype = as.indexType.NUMERIC\n  this.createIndex(options, policy, callback)\n}\n\n/**\n * @function Client#createStringIndex\n *\n * @summary Creates a secondary index of type String.\n *\n * @description This is a short-hand for calling {@link Client#createIndex}\n * with the <code>datatype</code> option set to <code>Aerospike.indexDataType.STRING</code>.\n *\n * @param {Object} options - Options for creating the index.\n * @param {string} options.ns - The namespace on which the index is to be created.\n * @param {string} options.set - The set on which the index is to be created.\n * @param {string} options.bin - The name of the bin which values are to be indexed.\n * @param {string} options.index - The name of the index to be created.\n * @param {module:aerospike.indexType} [options.type] - Type of index to be\n * created based on the type of values stored in the bin. This option needs to\n * be specified if the bin to be indexed contains list or map values and the\n * individual entries of the list or keys/values of the map should be indexed.\n * @param {Client~InfoPolicy} [options.policy] - Deprecated - set policy using\n * <code>policy</code> parameter instead.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~jobCallback} callback - The function to call when the operation completes.\n *\n * @see {@link Client#indexCreate}\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *\n *   var binName = 'name'\n *   var indexName = 'nameIndex'\n *   var options = { ns: 'test',\n *                   set: 'demo',\n *                   bin: binName,\n *                   index: indexName }\n *\n *   client.createStringIndex(options, function (error) {\n *     if (error) throw error\n *     console.info('secondary index %s on %s was created successfully', indexName, binName)\n *     client.close()\n *   })\n * })\n */\nClient.prototype.createStringIndex = function (options, policy, callback) {\n  options.datatype = as.indexType.STRING\n  this.createIndex(options, policy, callback)\n}\n\n/**\n * @function Client#createGeo2DSphereIndex\n *\n * @summary Creates a secondary, geospatial index.\n *\n * @description This is a short-hand for calling {@link Client#createIndex}\n * with the <code>datatype</code> option set to <code>Aerospike.indexDataType.GEO2DSPHERE</code>.\n *\n * @param {Object} options - Options for creating the index.\n * @param {string} options.ns - The namespace on which the index is to be created.\n * @param {string} options.set - The set on which the index is to be created.\n * @param {string} options.bin - The name of the bin which values are to be indexed.\n * @param {string} options.index - The name of the index to be created.\n * @param {module:aerospike.indexType} [options.type] - Type of index to be\n * created based on the type of values stored in the bin. This option needs to\n * be specified if the bin to be indexed contains list or map values and the\n * individual entries of the list or keys/values of the map should be indexed.\n * @param {Client~InfoPolicy} [options.policy] - Deprecated - set policy using\n * <code>policy</code> parameter instead.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~jobCallback} callback - The function to call when the operation completes.\n *\n * @see {@link Client#indexCreate}\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *\n *   var binName = 'location'\n *   var indexName = 'locationIndex'\n *   var options = { ns: 'test',\n *                   set: 'demo',\n *                   bin: binName,\n *                   index: indexName }\n *\n *   client.createGeo2DSphereIndex(options, function (error) {\n *     if (error) throw error\n *     console.info('secondary index %s on %s was created successfully', indexName, binName)\n *     client.close()\n *   })\n * })\n */\nClient.prototype.createGeo2DSphereIndex = function (options, policy, callback) {\n  options.datatype = as.indexType.GEO2DSPHERE\n  this.createIndex(options, policy, callback)\n}\n\n/**\n * @function Client#apply\n *\n * @summary Applies a User Defined Function (UDF) on a record in the database.\n *\n * @param {Key} key - The key, used to locate the record in the cluster.\n * @param {Object} udfArgs - Parameters used to specify which UDF function to execute.\n * @param {string} udfArgs.module - The name of the UDF module that was registered with the cluster.\n * @param {string} udfArgs.funcname - The name of the UDF function within the module.\n * @param {Array.<(number|string)>} udfArgs.args - List of arguments to pass to the UDF function.\n * @param {Client~ApplyPolicy} [policy] - The Apply Policy to use for this operation.\n * @param {Client~recordCallback} callback - The function to call when the operation has completed with the results of the operation.\n *\n * @since v2.0\n *\n * @see {@link Client#udfRegister}\n *\n * @example\n *\n * var key = new Key('test', 'demo', value')\n * var udfArgs = {module: 'my_udf_module', funcname: 'my_udf_function', args: ['abc', 123, 4.5]}\n *\n * client.apply(key, udfArgs, function (error, res, key) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     // handle success\n *   }\n * })\n *\n */\nClient.prototype.apply = function (key, udfArgs, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function')\n  }\n  this.sendCommand('applyAsync', [key, udfArgs, policy], function (err, result) {\n    callback(err, result, key)\n  })\n}\n\n/**\n * @function Client#execute\n *\n * @summary Alias for {@link Client#apply} for backwards compatibility.\n *\n * @param {Key} key - The key, used to locate the record in the cluster.\n * @param {Object} udfArgs - Parameters used to specify which UDF function to execute.\n * @param {string} udfArgs.module - The name of the UDF module that was registered with the cluster.\n * @param {string} udfArgs.funcname - The name of the UDF function within the module.\n * @param {Array.<(number|string)>} udfArgs.args - List of arguments to pass to the UDF function.\n * @param {Client~ApplyPolicy} [policy] - The Apply Policy to use for this operation.\n * @param {Client~recordCallback} callback - The function to call when the operation has completed with the results of the operation.\n *\n * @deprecated since v2.0 - renamed to {@link Client#apply}.\n */\nClient.prototype.execute = Client.prototype.apply\n\n/**\n * @function Client#exists\n *\n * @summary Checks the existance of a record in the database cluster.\n *\n * @param {Key} key - The key of the record to check for existance.\n * @param {Client~ReadPolicy} [policy] - The Read Policy to use for this operation.\n * @param {Client~existsCallback} callback - The function to call when the operation completes with the results of the operation.\n *\n * @example\n *\n * var key = new Key('test', 'demo', 'key1')\n * client.exists(key, function (error, metadata, key) {\n *   if (error && error.code === Aerospike.status.AEROSPIKE_ERR_RECORD_NOT_FOUND) {\n *     // record does not exist\n *   } else if (error) {\n *     // handle error\n *   } else {\n *     // record exists\n *   }\n * })\n */\nClient.prototype.exists = function exists (key, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function')\n  }\n  this.sendCommand('existsAsync', [key, policy], function (err, metadata) {\n    callback(err, metadata, key)\n  })\n}\n\n/**\n * @function Client#get\n *\n * @summary Using the key provided, reads a record from the database cluster.\n *\n * @param {Key} key - The key used to locate the record in the cluster.\n * @param {Client~ReadPolicy} [policy] - The Read Policy to use for this operation.\n * @param {Client~recordCallback} callback - The function to call when the operation completes with the results of the operation.\n *\n * @example\n *\n * var key = new Key('test', 'demo', 'key1')\n *\n * client.get(key, function (error, record, metadata) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     // handle success\n *   }\n * })\n */\nClient.prototype.get = function (key, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function')\n  }\n  this.sendCommand('getAsync', [key, policy], function (err, record, metadata) {\n    callback(err, record, metadata, key)\n  })\n}\n\n/**\n * @function Client#indexCreateWait\n *\n * @summary Wait until an index create command succeeds in aerospike cluster.\n *\n * @description This function actively polls the Aerospike cluster until the\n * specified index is ready to be queried.\n *\n * This method has been deprecated in v2.0. Use the {@link\n * IndexJob#waitUntilDone} method on the {@link IndexJob} instance returned\n * by the {@link Client#createIndex} callback instead.\n *\n * @param {string} namespace - The namespace on which the index is created.\n * @param {string} index - The name of the index.\n * @param {number} pollInterval - The poll interval in milliseconds.\n * @param {Client~doneCallback} callback - The function to call when the operation completes which the result of the operation.\n *\n * @deprecated since v2.0 - use {@link IndexJob#waitUntilDone} instead.\n */\nClient.prototype.indexCreateWait = function (namespace, index, pollInterval, callback) {\n  if (!this.isConnected(false)) {\n    this.sendError(callback, 'Not connected.')\n    return\n  }\n  var job = new IndexJob(this, namespace, index)\n  job.waitUntilDone(pollInterval, callback)\n}\n\n/**\n * @function Client#indexRemove\n *\n * @summary Removes the specified index.\n *\n * @param {string} namespace - The namespace on which the index was created.\n * @param {string} index - The name of the index.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~doneCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @example\n *\n * client.indexRemove('test', 'index', function (error) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     // handle success\n *   }\n * });\n */\nClient.prototype.indexRemove = function (namespace, index, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  this.sendCommand('indexRemove', [namespace, index, policy], callback)\n}\n\n/**\n * @function Client#info\n *\n * @summary Sends an info query to all nodes in the cluster.\n *\n * @description The <code>request</code> parameter is a string representing an\n * info request. If it is not specified, the cluster host(s) will send all\n * available info.\n *\n * The command queries each node in the cluster separately. The info callback\n * is called once for every cluster host that responds. The optional done callback\n * is called once all responses have been received.\n *\n * @param {string} [request] - The info request to send.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~infoCallback} infoCb - The function to call when an info response from a cluster host is received.\n * @param {Client~doneCallback} [doneCb] - The function to call once all info responses have been received and the operation completes.\n *\n * @deprecated since v2.4 - use {@link Client#infoAll} instead.\n *\n * @example <caption>Sending info command to whole cluster</caption>\n *\n * client.info('statistics', function (error, response, host) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     // process info response from host\n *   }\n * }, function () {\n *   // all response have been processed\n * })\n */\n\n/**\n * @function Client#info\n *\n * @summary Sends an info query to a specific cluster node.\n *\n * @description The <code>request</code> parameter is a string representing an\n * info request. If it is not specified, the cluster host will send all\n * available info.\n *\n * Please refer to the\n * <a href=\"http://www.aerospike.com/docs/reference/info\">Info Command Reference</a>\n * for a list of all available info commands.\n *\n * @param {string} [request] - The info request to send.\n * @param {Object} host - The address of the cluster host to send the request to.\n * @param {string} host.addr - The IP address or host name of the host.\n * @param {number} [host.port=3000] - The port of the host.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~infoCallback} infoCb - The function to call when an info response from a cluster host is received.\n *\n * @example <caption>Sending a 'statistics' info query to a specific host</caption>\n *\n * client.info('statistics', {addr: '127.0.0.1', port: 3000}, function (error, response) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     // handle success\n *   }\n * })\n */\nClient.prototype.info = function (request, host, policy, infoCb, doneCb) {\n  var argv = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments))\n  var argc = arguments.length\n  if (typeof argv[argc - 2] === 'function' && typeof argv[argc - 1] === 'function') {\n    doneCb = argv.pop()\n    infoCb = argv.pop()\n  } else if (typeof argv[argc - 1] === 'function') {\n    infoCb = argv.pop()\n  }\n\n  if (typeof request === 'function') {\n    request = null\n  }\n\n  if (typeof host === 'function') {\n    host = null\n  } else if (typeof host === 'object' && !(host.addr && host.port)) {\n    policy = host\n    host = null\n  } else if (typeof host === 'string') {\n    host = utils.parseHostString(host)\n  }\n\n  if (typeof policy === 'function') {\n    policy = null\n  }\n\n  if (!this.isConnected(false)) {\n    this.sendError(infoCb, 'Not connected.')\n    if (doneCb) process.nextTick(doneCb)\n    return\n  }\n\n  var self = this\n  if (host) {\n    this.as_client.info(request, host, policy, function asInfoCb (err, response) {\n      self.callbackHandler(infoCb, err, response, host)\n      doneCb()\n    })\n  } else {\n    this.as_client.infoForeach(request, policy, function asInfoCb (err, response, host) {\n      self.callbackHandler(infoCb, err, response, host)\n    }, doneCb)\n  }\n}\n\n/**\n * @function Client#infoAny\n *\n * @summary Sends an info query to a single, randomly selected cluster node.\n *\n * @description The <code>request</code> parameter is a string representing an\n * info request. If it is not specified, the cluster host(s) will send all\n * available info.\n *\n * @param {string} [request] - The info request to send.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~infoCallback} callback - The function to call when an info\n * response from a cluster host is received.\n *\n * @since v2.4.0\n *\n * @example <caption>Sending 'statistics' info command to random cluster node</caption>\n *\n * client.infoAny('statistics', function (error, response) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     // handle success\n *   }\n * })\n */\nClient.prototype.infoAny = function (request, policy, callback) {\n  if (typeof request === 'function') {\n    callback = request\n    request = null\n    policy = null\n  } else if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  this.sendCommand('info', [request, null, policy], callback)\n}\n\n/**\n * @function Client#infoAll\n *\n * @summary Sends an info query to all nodes in the cluster and collects the\n * results.\n *\n * @description The <code>request</code> parameter is a string representing an\n * info request. If it is not specified, the cluster hosts will send all\n * available info.\n *\n * @param {string} [request] - The info request to send.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~infoAllCallback} callback - The function to call when an info\n * response from all cluster hosts is received.\n *\n * @since v2.3.0\n *\n * @example <caption>Sending info command to whole cluster</caption>\n *\n * client.infoAll('statistics', function (error, responses) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     responses.forEach((function (info) {\n *       // handle response\n *     })\n *   }\n * })\n */\nClient.prototype.infoAll = function (request, policy, callback) {\n  if (typeof request === 'function') {\n    callback = request\n    request = null\n    policy = null\n  } else if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  if (!this.isConnected(false)) {\n    this.sendError(callback, 'Not connected.')\n    return\n  }\n\n  var error = null\n  var info = []\n  var self = this\n  this.as_client.infoForeach(request, policy, function infoAllCb (err, response, host) {\n    error = error || err\n    info.push({host: host, info: response, error: err})\n  }, function () {\n    self.callbackHandler(callback, error, info)\n  })\n}\n\n/**\n * @function Client#isConnected\n *\n * @summary Is client connected to any server nodes.\n *\n * @param {boolean} [checkTenderErrors=true] - Whether to consider a server\n * node connection that has had 5 consecutive info request failures during\n * cluster tender.\n *\n * @returns {boolean} <code>true</code> if the client is currently connected to any server nodes.\n *\n * @since v2.0\n */\nClient.prototype.isConnected = function (checkTenderErrors) {\n  if (typeof checkTenderErrors === 'undefined') {\n    checkTenderErrors = true\n  }\n  var connected = this.connected\n  if (connected && checkTenderErrors) {\n    connected = this.as_client.isConnected()\n  }\n  return connected\n}\n\n/**\n * @function Client#operate\n *\n * @summary Performs multiple operations on a single record.\n *\n * @param {Key} key - The key of the record.\n * @param {Object[]} operations - List of operations to perform on the record.\n * @param {Object} [metadata] - Meta data.\n * @param {Client~OperatePolicy} [policy] - The Operate Policy to use for this operation.\n * @param {Client~recordCallback} callback - The function to call when the operation completes with the results of the operation.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const op = Aerospike.operations\n *\n * var key = new Aerospike.Key('test', 'demo', 'mykey1')\n * var ops = [\n *   op.append('a', 'xyz'),\n *   op.incr('b', 10),\n *   op.read('b')\n * ]\n *\n * Aerospike.connect(function (error, client) {\n *   client.operate(key, ops, function (error, record) {\n *     if (error) {\n *       // handle failure\n *     } else {\n *       console.log('b', record['b']) // value of 'b' returned by the `read` operation\n *     }\n *   })\n *   client.close()\n * })\n */\nClient.prototype.operate = function (key, operations, metadata, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  } else if (typeof metadata === 'function') {\n    callback = metadata\n    metadata = null\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function')\n  }\n  this.sendCommand('operateAsync', [key, operations, metadata, policy], function (err, record, metadata) {\n    callback(err, record, metadata, key)\n  })\n}\n\n/**\n * @function Client#append\n *\n * @summary Shortcut for applying the {@link\n * module:aerospike/operations.append} operation to one or more record bins.\n *\n * @description This function works on bins of type string or bytes; to append\n * a new value (of any type) to a bin containing a list of existing values, use\n * the {@link module:aerospike/lists.append} operation instead.\n *\n * @param {Key} key - The key of the record.\n * @param {Object[]} bins - The key-value mapping of bin names and the\n * corresponding values to append to the bin value. The bins must contain\n * either string or byte array values and the values to append must be of the\n * same type.\n * @param {Object} [metadata] - Meta data.\n * @param {Client~OperatePolicy} [policy] - The Operate Policy to use for this operation.\n * @param {Client~recordCallback} callback - The function to call when the operation completes with the results of the operation.\n *\n * @see {@link Client#operate}\n * @see {@link module:aerospike/operations.append}\n */\n\n/**\n * @function Client#prepend\n *\n * @summary Shortcut for applying the {@link module:aerospike/operations.prepend} operation to one or more record bins.\n *\n * @param {Key} key - The key of the record.\n * @param {Object[]} bins - The key-value mapping of bin names and the corresponding values to prepend to the bin value.\n * @param {Object} [metadata] - Meta data.\n * @param {Client~OperatePolicy} [policy] - The Operate Policy to use for this operation.\n * @param {Client~recordCallback} callback - The function to call when the operation completes with the results of the operation.\n *\n * @see {@link Client#operate}\n * @see {@link module:aerospike/operations.prepend}\n */\n\n/**\n * @function Client#incr\n *\n * @summary Shortcut for applying the {@link module:aerospike/operations.incr} operation to one or more record bins.\n *\n * @param {Key} key - The key of the record.\n * @param {Object[]} bins - The key-value mapping of bin names and the corresponding values to use to increment the bin values with.\n * @param {Object} [metadata] - Meta data.\n * @param {Client~OperatePolicy} [policy] - The Operate Policy to use for this operation.\n * @param {Client~recordCallback} callback - The function to call when the operation completes with the results of the operation.\n *\n * @since v2.0\n *\n * @see {@link Client#operate}\n * @see {@link module:aerospike/operations.incr}\n */\n\n// Shortcuts for some operations\n;['append', 'prepend', 'incr'].forEach(function (op) {\n  Client.prototype[op] = function (key, bins, metadata, policy, callback) {\n    var ops = Object.keys(bins).map(function (bin) {\n      return operations[op](bin, bins[bin])\n    })\n    this.operate(key, ops, metadata, policy, callback)\n  }\n})\n\n/**\n * @function Client#add\n *\n * @summary Alias for {@link Client#incr} for backwards compatibility.\n *\n * @param {Key} key - The key of the record.\n * @param {Object[]} bins - The key-value mapping of bin names and the corresponding values to use to increment the bin values with.\n * @param {Object} [metadata] - Meta data.\n * @param {Client~OperatePolicy} [policy] - The Operate Policy to use for this operation.\n * @param {Client~recordCallback} callback - The function to call when the operation completes with the results of the operation.\n *\n * @deprecated since v2.0 - renamed to {@link Client#incr}.\n */\nClient.prototype.add = Client.prototype.incr\n\n/**\n * @function Client#put\n *\n * @summary Writes a record to the database cluster.\n *\n * @description\n * If the record exists, it modifies the record with bins provided.\n * To remove a bin, set its value to <code>null</code>.\n *\n * __Note:__ The client does not perform any automatic data type conversions.\n * Attempting to write an unsupported data type (e.g. boolean) into a record\n * bin will cause an error to be returned. Setting an <code>undefined</code>\n * value will also cause an error.\n *\n * @param {Key} key - The key of the record.\n * @param {object} record - A record object used for specifying the fields to store.\n * @param {object} [metadata] - Meta data.\n * @param {Client~WritePolicy} [policy] - The Write Policy to use for this operation.\n * @param {Client~writeCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @example\n *\n * const Key = Aerospike.Key\n *\n * var key = new Key('test', 'demo', 'key1')\n * var rec = {\n *   a: 'xyz',\n *   b: 123\n * }\n *\n * client.put(key, rec, function (error, key) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     // handle success\n *   }\n * })\n */\nClient.prototype.put = function (key, record, metadata, policy, callback) {\n  if (typeof metadata === 'function') {\n    callback = metadata\n    metadata = null\n  } else if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function')\n  }\n  this.sendCommand('putAsync', [key, record, metadata, policy], function (err) {\n    callback(err, key)\n  })\n}\n\n/**\n * @function Client#query\n *\n * @summary Creates a new {@link Query} instance, which is used to define query\n * in the database.\n *\n * @param {string} ns - The namespace to be queried.\n * @param {string} set - The set on which the query is to be executed.\n * @param {object} [options] - Query parameters. See {@link Query} constructor for details.\n *\n * @see {@link Query}\n *\n * @example\n *\n * const filter = Aerospike.filter\n *\n * var statement = {}\n * statment.filters: [filter.equal('color', 'blue')]\n *\n * var query = client.query(ns, set, statment)\n * var stream = query.execute()\n */\nClient.prototype.query = function (ns, set, options) {\n  options = options || {}\n  if (!this.isConnected()) {\n    throw new AerospikeError('Not connected.')\n  }\n  return new Query(this, ns, set, options)\n}\n\n/**\n * @function Client#remove\n *\n * @summary Removes a record with the specified key from the database cluster.\n *\n * @param {Key} key - The key of the record.\n * @param {Client~RemovePolicy} [policy] - The Remove Policy to use for this operation.\n * @param {Client~writeCallback} callback - The function to call when the operation completes with the results of the operation.\n *\n * @example\n *\n * const Key = Aerospike.Key\n\n * client.remove(new Key('test', 'demo', 'key1'), function (error, key) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     // handle success\n *   }\n * })\n */\nClient.prototype.remove = function (key, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function')\n  }\n  this.sendCommand('removeAsync', [key, policy], function (err) {\n    callback(err, key)\n  })\n}\n\n/**\n * @function Client#scan\n *\n * @summary Creates a new {@link Scan} instance in order to execute a database\n * scan using the Scan API.\n *\n * @see {@link Scan} constructor for options that can be used to initialize a\n * new instance.\n *\n * @param {string} ns - The namescape.\n * @param {string} set - The name of a set.\n * @param {object} [options] - Scan parameters. See {@link Scan} constructor for details.\n *\n * @since v2.0\n */\nClient.prototype.scan = function (ns, set, options) {\n  options = options || {}\n  if (!this.isConnected()) {\n    throw new AerospikeError('Not connected.')\n  }\n  return new Scan(this, ns, set, options)\n}\n\n/**\n * @function Client#select\n *\n * @summary Retrieves selected bins for a record of given key from the database cluster.\n *\n * @param {Key} key - The key of the record.\n * @param {string[]} bins - A list of bin names for the bins to be returned.\n * @param {Client~ReadPolicy} [policy] - The Read Policy to use for this operation.\n * @param {Client~recordCallback} callback - The function to call when the operation completes with the results of the operation.\n *\n * @example\n *\n * const Key = Aerospike.Key\n *\n * client.select(new Key('test', 'demo', 'key1'), ['name', 'age'], function (error, record, metadata, key) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     // handle success\n *   }\n * })\n */\nClient.prototype.select = function (key, bins, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function')\n  }\n  this.sendCommand('selectAsync', [key, bins, policy], function (err, record, metadata) {\n    callback(err, record, metadata, key)\n  })\n}\n\n/** @private */\nClient.prototype.sendCommand = function (cmd, args, callback) {\n  if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function')\n  }\n  if (!this.isConnected(false)) {\n    this.sendError(callback, 'Not connected.')\n    return\n  }\n\n  // C client will call the callback function synchronously under certain error\n  // conditions; if we detect a synchronous callback we need to schedule the JS\n  // callback to be called asynchronously anyway.\n  var sync = true\n\n  var cmdStackTrace = null\n  if (this.captureStackTraces) {\n    cmdStackTrace = new AerospikeError().stack\n  }\n\n  var self = this\n  args.push(function (err, arg1, arg2, arg3) {\n    if (err && cmdStackTrace) {\n      err.stack = cmdStackTrace\n    }\n    if (sync) {\n      // TODO: replace with process.nextTick once we drop support for Node.js v0.12\n      setImmediate(self.callbackHandler, callback, err, arg1, arg2, arg3)\n    } else {\n      return self.callbackHandler(callback, err, arg1, arg2, arg3)\n    }\n  })\n\n  this.as_client[cmd].apply(this.as_client, args)\n  sync = false // if we get here before the cb was called the cb is async\n}\n\n/** @private */\nClient.prototype.sendError = function (callback, error) {\n  if (typeof error === 'string') {\n    error = { message: error }\n  }\n  error.code = error.code || as.status.AEROSPIKE_ERR_CLIENT\n  error.message = error.message || 'Client Error'\n  Error.captureStackTrace(error)\n  var self = this\n  process.nextTick(function () {\n    self.callbackHandler(callback, error)\n  })\n}\n\n/**\n * @function Client#truncate\n *\n * @summary Removes records in specified namespace/set efficiently.\n *\n * @description This method is many orders of magnitude faster than deleting\n * records one at a time. Works with Aerospike Server version >= 3.12.\n *\n * @param {string} ns - Required namespace.\n * @param {string} set - Optional set name. Set to <code>null</code> to delete\n * all sets in namespace.\n * @param {number} before_nanos - Optionally delete records before given last\n * update time. Units are in nanoseconds since unix epoch (1970-01-01). If\n * specified, the value must be before the current time. Pass in 0 to delete\n * all records in namespace/set regardless of last udpate time.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~doneCallback} callback - The function to call when the\n * operation completes with the result of the operation.\n */\nClient.prototype.truncate = function (ns, set, beforeNanos, policy, callback) {\n  if (typeof set === 'function') {\n    callback = set\n    set = null\n    beforeNanos = 0\n    policy = null\n  } else if (typeof beforeNanos === 'function') {\n    callback = beforeNanos\n    beforeNanos = 0\n    policy = null\n  } else if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  this.sendCommand('truncate', [ns, set, beforeNanos, policy], callback)\n}\n\n/**\n * @function Client#udfRegister\n *\n * @summary Registers a UDF module with the database cluster.\n *\n * @description This method loads a Lua script from the local filesystem into\n * the Aerospike database cluster and registers it for use as a UDF module. The\n * client uploads the module to a single cluster node. It then gets distributed\n * within the whole cluster automatically. The callback function is called once\n * the initial upload into the cluster has completed (or if an error occurred\n * during the upload). To verify that the UDF module has been registered on\n * every cluster node you can use the {@link Client#udfRegisterWait} method.\n *\n * @param {string} path - The file path to the Lua script to load into the server.\n * @param {number} [udfType] - Language of the UDF script. Lua is the default\n * and only supported scripting language for UDF modules at the moment; ref.\n * {@link module:aerospike.language}.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~doneCallback} callback - The function to call when the\n * operation completes with the result of the operation.\n *\n * @see {@link Client#udfRegisterWait} for an example.\n */\nClient.prototype.udfRegister = function (path, udfType, policy, callback) {\n  if (typeof udfType === 'function') {\n    callback = udfType\n    udfType = null\n  } else if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  if (typeof udfType === 'object') {\n    policy = udfType\n    udfType = null\n  }\n  this.sendCommand('udfRegister', [path, udfType, policy], callback)\n}\n\n/**\n * @function Client#udfRegisterWait\n *\n * @summary Waits until a UDF module has been successfully registered on all\n * cluster nodes.\n *\n * @description This function periodically polls the cluster nodes to check for\n * the presence of a previously registered UDF module. It calls the provided\n * callback function once all nodes have successfully registered the module.\n *\n * @param {string} udfModule - The name of the UDF module; this is the basename\n * of the UDF file registered with {@link Client#udfRegister}, i.e. the\n * filename, optionally including the file extension, but without the directory\n * name.\n * @param {number} pollInterval - Poll interval in milliseconds used to check\n * the presence of the on the cluster nodes.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~doneCallback} callback - The function to call when the\n * operation completes with the result of the operation.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const path = require('path')\n *\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *\n *   var path = './udf/my_module.lua'\n *   client.udfRegister(path, (error) => {\n *     if (error) throw error\n *\n *     var module = path.basename(path)\n *     client.udfRegisterWait(module, 100, (error) => {\n *       if (error) throw error\n *\n *       // UDF module was successfully registered on all cluster nodes\n *\n *       client.close()\n *     })\n *   })\n * })\n */\nClient.prototype.udfRegisterWait = function (udfModule, pollInterval, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  this.sendCommand('udfRegisterWait', [udfModule, pollInterval, policy], callback)\n}\n\n/**\n * @function Client#udfRemove\n *\n * @summary Removes a UDF module from the cluster.\n *\n * @param {string} udfModule - The filename of the UDF module.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Client~doneCallback} callback - The function to call when the operation completes which the result of the operation.\n *\n * @example\n *\n * client.udfRemove('my_module', function (error) {\n *   if (error) {\n *     // handle failure\n *   } else {\n *     // UDF module was successfully removed from the cluster\n *   }\n * })\n */\nClient.prototype.udfRemove = function (udfModule, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  this.sendCommand('udfRemove', [udfModule, policy], callback)\n}\n\nClient.prototype.updateLogging = function (logConfig) {\n  this.as_client.updateLogging(logConfig)\n}\n\n/**\n * @typedef {Object} Client~ApplyPolicy\n *\n * A policy affecting the behavior of apply operations.\n *\n * @property {number} timeout - Maximum time in milliseconds to wait for the operation to complete.\n * @property {number} key - Specifies the behavior for the key.\n * @property {number} commitLevel - Specifies the number of replicas required\n * to be committed successfully when writing before returning transaction succeeded.\n * @property {number} ttl - The time-to-live (expiration) of the record in seconds.\n * @property {boolean} [durableDelete=false] - Specifies whether a {@link\n * http://www.aerospike.com/docs/guide/durable_deletes.html|tombstone} should\n * be written in place of a record that gets deleted as a result of this\n * operation.\n *\n * @see {@link module:aerospike.policy} for supported policy values.\n */\n\n/**\n * @typedef {Object} Client~ReadPolicy\n *\n * A policy affecting the behavior of read operations.\n *\n * @property {number} timeout - Maximum time in milliseconds to wait for the operation to complete.\n * @property {number} key - Specifies the behavior for the key.\n * @property {number} replica - Specifies the replica to be consulted for the read.\n * @property {number} concistencyLevel - Specifies the number of replicas consulted when reading for the desired consistency guarantee.\n *\n * @see {@link module:aerospike.policy} for supported policy values.\n */\n\n/**\n * @typedef {Object} Client~WritePolicy\n *\n * A policy affecting the behavior of write operations.\n *\n * @property {number} timeout - Maximum time in milliseconds to wait for the operation to complete.\n * @property {number} compressionThreshold - Minimum record size beyond which it is compressed and sent to the server.\n * @property {number} key - Specifies the behavior for the key.\n * @property {number} gen - Specifies the behavior for the generation value.\n * @property {number} exists - Specifies the behavior for the existence of the record.\n * @property {number} commitLevel - Specifies the number of replicas required\n * to be committed successfully when writing before returning transaction succeeded.\n * @property {boolean} [durableDelete=false] - Specifies whether a {@link\n * http://www.aerospike.com/docs/guide/durable_deletes.html|tombstone} should\n * be written in place of a record that gets deleted as a result of this\n * operation.\n *\n * @see {@link module:aerospike.policy} for supported policy values.\n */\n\n/**\n * @typedef {Object} Client~RemovePolicy\n *\n * A policy affecting the behavior of remove operations.\n *\n * @property {number} timeout - Maximum time in milliseconds to wait for the operation to complete.\n * @property {number} generation - The generation of the record.\n * @property {number} key - Specifies the behavior for the key.\n * @property {number} gen - Specifies the behavior for the generation value.\n * @property {number} commitLevel - Specifies the number of replicas required\n * to be committed successfully when writing before returning transaction succeeded.\n * @property {boolean} [durableDelete=false] - Specifies whether a {@link\n * http://www.aerospike.com/docs/guide/durable_deletes.html|tombstone} should\n * be written in place of a record that gets deleted as a result of this\n * operation.\n *\n * @see {@link module:aerospike.policy} for supported policy values.\n */\n\n/**\n * @typedef {Object} Client~BatchPolicy\n *\n * A policy affecting the behavior of batch operations.\n *\n * @property {number} timeout - Maximum time in milliseconds to wait for the operation to complete.\n */\n\n/**\n * @typedef {Object} Client~OperatePolicy\n *\n * A policy affecting the behavior of operate operations.\n *\n * @property {number} timeout - Maximum time in milliseconds to wait for the operation to complete.\n * @property {number} key - Specifies the behavior for the key.\n * @property {number} gen - Specifies the behavior for the generation value.\n * @property {number} replica - Specifies the replica to be consulted for the read.\n * @property {number} concistencyLevel - Specifies the number of replicas consulted when reading for the desired consistency guarantee.\n * @property {number} commitLevel - Specifies the number of replicas required\n * to be committed successfully when writing before returning transaction succeeded.\n * @property {boolean} [durableDelete=false] - Specifies whether a {@link\n * http://www.aerospike.com/docs/guide/durable_deletes.html|tombstone} should\n * be written in place of a record that gets deleted as a result of this\n * operation.\n *\n * @see {@link module:aerospike.policy} for supported policy values.\n */\n\n/**\n * @typedef {Object} Client~InfoPolicy\n *\n * A policy affecting the behavior of info operations.\n *\n * @property {number} timeout - Maximum time in milliseconds to wait for the operation to complete.\n * @property {boolean} sendAsIs - Send request without any further processing.\n * @property {boolean} checkBounds - Ensure the request is within allowable size limits.\n */\n\n/**\n * @typedef {Object} Client~AdminPolicy\n *\n * A policy affecting the behavior of admin operations.\n *\n * @property {number} timeout - Maximum time in milliseconds to wait for the operation to complete.\n */\n\n/**\n * @typedef {Object} Client~ScanPolicy\n *\n * A policy affecting the behavior of scan operations.\n *\n * @property {number} timeout - Maximum time in milliseconds to wait for the operation to complete.\n * @property {boolean} failOnClusterChange - Abort the scan if the cluster is not in a stable state.\n * @property {boolean} [durableDelete=false] - Specifies whether a {@link\n * http://www.aerospike.com/docs/guide/durable_deletes.html|tombstone} should\n * be written in place of a record that gets deleted as a result of this\n * operation.\n */\n\n/**\n * @typedef {Object} Client~QueryPolicy\n *\n * A policy affecting the behavior of query operations.\n *\n * @property {number} timeout - Maximum time in milliseconds to wait for the operation to complete.\n */\n\n/**\n * @callback Client~doneCallback\n *\n * @summary Callback function called when an operation has completed.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n */\n\n/**\n * @callback Client~recordCallback\n *\n * @summary Callback function returning a single record from the cluster.\n *\n * @description\n *\n * If the operation was successful, <code>null</code> will be returned for the\n * error parameter. If there was an error, <code>record</code> will be\n * <code>undefined</code> and the <code>error</code> paramter will provide more\n * information about the error.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n * @param {Object} [record] - The record bins. Depending on the operation, the full record or a selection of bins will be returned.\n * @param {Object} [metadata] - The metadata of the record.\n * @param {Key} [key] - The key of the record.\n */\n\n/**\n * @callback Client~writeCallback\n *\n * @summary Callback function called when a write operation on a single record has completed.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n * @param {Key} key - The key of the record.\n */\n\n/**\n * @callback Client~batchRecordsCallback\n *\n * @summary Callback function returning one or more records from the cluster.\n *\n * @description\n *\n * If the operation was successful, <code>null</code> will be returned for the\n * error parameter. If there was an error, <code>results</code> will be\n * <code>undefined</code> and the <code>error</code> paramter will provide more\n * information about the error.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n * @param {Object[]} [results] - The results of the operation. Depending on the\n * specific operation, the full record, a selection of bins or just the meta\n * data for the record will be included in the results.\n * @param {number} results.status - The status of the record.\n * @param {Key} [results.key] - The key of the record.\n * @param {Object} [results.record] - The record bins read from the cluster.\n * @param {Object} results.metadata - The metadata of the record.\n */\n\n/**\n * @callback Client~connectCallback\n *\n * @summary The function called when the client has successfully connected to the server.\n *\n * @description\n *\n * Once you receive the connect callback the client instance\n * returned in the callback is ready to accept commands for the Aerospike\n * cluster.\n *\n * If an error occurred while connecting to the cluster, the\n * <code>client</code> parameter will be <code>undefined</code> and the\n * <code>error</code> parameter will include more information about the error.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n * @param {Client} [client] - Aerospike client instance.\n */\n\n/**\n * @callback Client~infoCallback\n *\n * @summary The function called when a cluster host responds to an info query.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n * @param {string} [response] - The response string with the requested info.\n * @param {Object} [host] - The address of the host which send the response.\n * @param {string} host.addr - The ip address or host name of the host.\n * @param {number} host.port - The port number of the host.\n */\n\n/**\n * @callback Client~infoAllCallback\n *\n * @summary The function called when all cluster nodes have responded to the\n * info request. Note that the error parameter in the callback will be\n * non-<code>null</code> if at least one of the cluster hosts responded with an\n * error to the info request. To check the status of the info requeset for each\n * individual cluster node, you need to check the list of responses returned in\n * the second parameter..\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n * @param {Object[]} [responses] - The response string with the requested info.\n * @param {string} responses[].info - The response string with the requested info.\n * @param {?AerospikeError} responses[].error - The error code and message or <code>null</code> if the info request to this cluster host was successful.\n * @param {Object} responses[].host - The address of the host which send the response.\n * @param {string} responses[].host.addr - The ip address or host name of the host.\n * @param {number} responses[].host.port - The port number of the host.\n */\n\n/**\n * @callback Client~jobCallback\n *\n * @summary Function called when a potentially long-running job has been started.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n * @param {Job} [job] - Handle on a potentially long-running job which can be used to check for job completion.\n */\n\nmodule.exports = Client\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/config.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n/**\n * @class Config\n * @classdesc Configuration for an Aerospike client instance.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const config = {\n *   user: process.env.DATABASE_USER,\n *   password: process.env.DATABASE_PASSWORD,\n *   hosts: '192.168.1.42:3000',\n *   log: {\n *     level: Aerospike.log.INFO,\n *     file: 2 // log to stderr\n *   }\n * }\n * Aerospike.connect(config, function (error, client) {\n *   if (error) {\n *     console.error('Failed to connect to cluster: %s', error.message)\n *     process.exit()\n *   }\n *   // client is ready to accept commands\n *   client.close()\n * })\n */\nfunction Config (config) {\n  config = config || {}\n\n  /**\n   * @name Config#user\n   * @summary The user name to use when authenticating to the cluster.\n   * @description Leave empty for clusters running without access management.\n   * (Security features are available in the Aerospike Database Enterprise\n   * Edition.)\n   * @type {string}\n   */\n  if (typeof config.user === 'string') {\n    this.user = config.user\n  }\n\n  /**\n   * @name Config#password\n   * @summary The password to use when authenticating to the cluster.\n   * @type {string}\n   */\n  if (typeof config.password === 'string') {\n    this.password = config.password\n  }\n\n  /**\n   * @name Config#clusterName\n   * @summary Expected Cluster Name.\n   * @description If not <code>null</code>, server nodes must return this\n   * cluster name in order to join the client's view of the cluster. Should\n   * only be set when connecting to servers that support the \"cluster-name\"\n   * info command.\n   * @type {string}\n   * @since v2.4\n   */\n  this.clusterName = config.clusterName\n\n  /**\n   * @name Config#hosts\n   * @summary List of hosts with which the client should attempt to connect.\n   * @description If not specified, the client attempts to read the host list\n   * from the <code>AEROSPIKE_HOSTS</code> environment variable or else falls\n   * back to use a default value of \"localhost\".\n   * @type {(Object[] | string)}\n   *\n   * @example <caption>Setting <code>hosts</code> using a String</caption>\n   *\n   * const Aerospike = require('aerospike')\n   *\n   * var hosts = '192.168.0.1:3000,192.168.0.2:3000'\n   * Aerospike.connect({hosts: hosts}, (err, client) => {\n   *   if (err) throw err\n   *   // ...\n   *   client.close()\n   * })\n   *\n   * @example <caption>Setting <code>hosts</code> using an array of hostname/port tuples</caption>\n   *\n   * const Aerospike = require('aerospike')\n   *\n   * var hosts = [\n   *   { addr: '192.168.0.1', port: 3000 },\n   *   { addr: '192.168.0.2', port: 3000 }\n   * ]\n   * Aerospike.connect({hosts: hosts}, (err, client) => {\n   *   if (err) throw err\n   *   // ...\n   *   client.close()\n   * })\n   */\n  this.hosts = config.hosts || process.env.AEROSPIKE_HOSTS || 'localhost:3000'\n\n  /**\n   * @name Config#port\n   * @summary Default port to use for any host address, that does not\n   * explicitly specify a port number. Default is 3000.\n   * @type {number}\n   *\n   * @since v2.4\n   */\n  if (typeof config.port === 'number') {\n    this.port = config.port\n  }\n\n  /**\n   * @name Config#policies\n   * @summaries Global client policies.\n   * @description A policy is a set of values which modify the behavior of an\n   * operation, like timeouts or how an operation handles data. The policies\n   * defined in the configuration are used as global defaults, which can be\n   * overridden by individual operations as needed.\n   * @type {Object}\n   *\n   * @example <caption>Setting a default timeout value</caption>\n   *\n   * const Aerospike = require('aerospike')\n   *\n   * var config = {\n   *   policies: {\n   *     timeout: 100\n   *   }\n   * }\n   * Aerospike.connect(config, (err, client) => {\n   *   if (err) throw err\n   *   var key = new Aerospike.Key('test', 'demo', 123)\n   *\n   *   // use default timeout policy\n   *   client.put(key, {x: 42}, (err) => {\n   *     if (err) throw err\n   *\n   *     // override global timeout policy\n   *     client.get(key, { timeout: 200 }, (err, record) => {\n   *       if (err) throw err\n   *       console.log(record)\n   *       client.close()\n   *     })\n   *   })\n   * })\n   */\n  if (typeof config.policies === 'object') {\n    this.policies = config.policies\n  }\n\n  /**\n   * @name Config#log\n   * @summary Configuration for logging done by the client.\n   * @type {Object}\n   *\n   * @property {number} [log.level] - Log level; see {@link\n   * module:aerospike.log} for details.\n   * @property {number} [log.file] - File descriptor opened using fs.open();\n   * specify 1 for stdout and 2 for stdin.\n   *\n   * @example <caption>Enabling debug logging to a separate log file</caption>\n   *\n   * const Aerospike = require('aerospike')\n   * const fs = require('fs')\n   *\n   * var debuglog = fs.openSync('./debug.log')\n   * var config = {\n   *   log: {\n   *     level: Aerospike.log.DEBUG,\n   *     file: debuglog\n   *   }\n   * }\n   * Aerospike.connect(config, (err, client) => {\n   *   if (err) throw err\n   *   // ...\n   *   client.close()\n   * })\n   */\n  if (typeof config.log === 'object') {\n    this.log = config.log\n  }\n\n  /**\n   * @name Config#connTimeoutMs\n   * @summary Initial host connection timeout in milliseconds.\n   * @description The client observes this timeout when opening a connection to\n   * the cluster for the first time. Default is 1,000 milliseconds.\n   * @type {number}\n   */\n  if (Number.isInteger(config.connTimeoutMs)) {\n    this.connTimeoutMs = config.connTimeoutMs\n  }\n\n  /**\n   * @name Config#tenderInterval\n   * @summary Polling interval in milliseconds for cluster tender. Default is\n   * 1,000 milliseconds.\n   * @type {number}\n   */\n  if (Number.isInteger(config.tenderInterval)) {\n    this.tenderInterval = config.tenderInterval\n  }\n\n  /**\n   * @name Config#maxConnsPerNode\n   * @summary Maximum number of asynchronous connections allowed for each node.\n   * @description New transactions will be rejected with an\n   * <code>AEROSPIKE_ERR_NO_MORE_CONNECTIONS</code> error if the limit would be\n   * exceeded. Default is 300.\n   * @type {number}\n   */\n  if (Number.isInteger(config.maxConnsPerNode)) {\n    this.maxConnsPerNode = config.maxConnsPerNode\n  }\n\n   /**\n    * @name Config#modlua\n    * @summary Configuration values for the mod-lua system and user paths.\n    * @type {Object}\n    *\n    * @property {string} [modlua.systemPath] - Path to system Lua scripts.\n    * @property {string} [modlua.userPath] - Path to user Lua scripts.\n    */\n  if (typeof config.modlua === 'object') {\n    // TODO: reimplement logic to determine default paths (see conversions.cc)\n    this.modlua = config.modlua\n  }\n\n  /**\n   * @name Config#sharedMemory\n   * @summary Shared memory configuration.\n   * @description This allows multiple client instances running in separate\n   * processes on the same machine to share cluster status, including nodes and\n   * data partion maps.\n   * @type {Object}\n   * @see {@link http://www.aerospike.com/docs/client/c/usage/shm.html#operational-notes|Operational Notes}\n   * @tutorial node_clusters\n   *\n   * @property {boolean} [enable=true] - Whether to enable/disable usage of\n   * shared memory.\n   * @property {number} key - Key used to identify the shared\n   * memory segment; the same key needs to be used on all client instances.\n   * @property {number} [maxNodes=16] - Sets the max. number of\n   * server nodes in the cluster - this value is required to size the shared\n   * memory segment. Ensure that you leave a cushion between actual server node\n   * cound and <code>maxNodes</code> so that you can add new nodes without\n   * rebooting the client.\n   * @property {number} [maxNamespaces=8] - Sets the max. number of\n   * namespaces used in the cluster - this value is required to size the shared\n   * memory segment. Ensure that you leave a cushion between actual namespace\n   * count and <code>maxNamespaces</code> so that you can add new namespaces\n   * without rebooking the client.\n   * @property {number} [takeoverThresholdSeconds=30] - Expiration\n   * time in seconds for the lock on the shared memory segment; if the cluster\n   * status has not been updated after this many seconds another client instance\n   * will take over the shared memory cluster tending.\n   *\n   * @example <caption>Using shared memory in a clustered setup</caption>\n   *\n   * const Aerospike = require('aerospike')\n   * const cluster = require('cluster')\n   *\n   * const config = {\n   *   sharedMemory: {\n   *     key: 0xa5000000\n   *   }\n   * }\n   * const client = Aerospike.client(config)\n   * const noWorkers = 4\n   *\n   * if (cluster.isMaster) {\n   *   // spawn new worker processes\n   *   for (var i = 0; i < noWorkers; i++) {\n   *     cluster.fork()\n   *   }\n   * } else {\n   *   // connect to Aerospike cluster in each worker process\n   *   client.connect((err) => { if (err) throw err })\n   *\n   *   // handle incoming HTTP requests, etc.\n   *   // http.createServer((request, response) => { ... })\n   *\n   *   // close DB connection on shutdown\n   *   client.close()\n   * }\n   */\n  if (typeof config.sharedMemory === 'object') {\n    this.sharedMemory = config.sharedMemory\n  }\n}\n\nmodule.exports = Config\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/index_job.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the 'License')\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an 'AS IS' BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nconst as = require('../build/Release/aerospike.node')\nconst Info = require('./info')\nconst Job = require('./job')\n\nconst util = require('util')\n\n/**\n * @class IndexJob\n * @classdesc Potentially long-running index creation job.\n * @extends Job\n *\n * @see {@link Client#createIndex}\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *\n *   // create index for vehicle's current location\n *   var binName = 'location'\n *   var indexName = 'locationIndex'\n *   var options = { ns: 'test'\n *                   set: 'demo'\n *                   bin: binName,\n *                   index: indexName,\n *                   datatype: Aerospike.indexDataType.GEO2DSPHERE }\n *   client.createIndex(options, (error, job) => {\n *     if (error) throw error\n *\n *     // wait for index creation to complete\n *     var pollInterval = 100\n *     job.waitUntilDone(pollInterval, (error) => {\n *       if (error) throw error\n *       console.info('secondary index %s on %s was created successfully', indexName, binName)\n *       client.close()\n *     })\n *   })\n * })\n */\nfunction IndexJob (client, namespace, indexName) {\n  this.client = client\n  this.namespace = namespace\n  this.indexName = indexName\n}\nutil.inherits(IndexJob, Job)\n\n/**\n * @private\n */\nIndexJob.prototype.hasCompleted = function (sindexInfo) {\n  var completed = false\n  if (sindexInfo.length > 0) {\n    var inProgress = sindexInfo.some(function (info) {\n      var pct = info['load_pct'] || 0\n      return pct >= 0 && pct < 100\n    })\n    completed = !inProgress\n  }\n  return completed\n}\n\n/**\n * Fetches info for the secondary index from each cluster node.\n *\n * @private\n */\nIndexJob.prototype.info = function (callback) {\n  var client = this.client\n  var sindex = 'sindex/' + this.namespace + '/' + this.indexName\n  var sindexInfo = []\n  var error = null\n  var infoCb = function (err, info) {\n    if (err && err.code !== as.status.AEROSPIKE_ERR_INDEX_NOT_FOUND) {\n      error = err\n    } else {\n      info = Info.parseInfo(info)\n      sindexInfo.push(info[sindex] || {load_pct: 0})\n    }\n  }\n  var doneCb = function () {\n    client.callbackHandler(callback, error, sindexInfo)\n  }\n  this.client.info(sindex, infoCb, doneCb)\n}\n\n/**\n * @function IndexJob#waitUntilDone\n *\n * @summary Wait until the job of creating a secondary index has completed.\n *\n * @param {number} [pollInterval=1000] - Interval in milliseconds to use when polling the cluster nodes.\n * @param {Client~doneCallback} callback - The function to call when the operation completes.\n */\n\nmodule.exports = IndexJob\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/info.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the 'License')\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an 'AS IS' BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n/**\n * @module aerospike/info\n *\n * @description Utility methods for dealing with info data returned by Aerospike cluster nodes.\n *\n * @see {@link Client#info}\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *\n *   var infoCb = function (error, infoStr) {\n *     if (error) {\n *       console.error('error retrieving info: %s', error.message)\n *     } else {\n *       var info = Aerospike.info.parseInfo(infoStr)\n *       console.log(info) // => { features:\n *                         //      [ 'cdt-list',\n *                         //        'pipelining',\n *                         //        'geo',\n *                         //        ...,\n *                         //        'udf' ] }\n *     }\n *   }\n *   client.info('features', infoCb, () => client.close())\n * })\n */\n\nfunction parseValue (value) {\n  if (Number(value).toString() === value) {\n    return Number(value)\n  }\n  return value\n}\n\nfunction parseKeyValue (str, sep1, sep2) {\n  var result = {}\n  str.split(sep1).forEach(function (kv) {\n    if (kv.length > 0) {\n      kv = kv.split(sep2, 2)\n      result[kv[0]] = parseValue(kv[1])\n    }\n  })\n  return result\n}\n\n/**\n * @function module:aerospike/info.parseInfo\n *\n * @summary Parses the info string returned from a cluster node into key-value pairs.\n *\n * @param {string} info - The info string returned by the cluster node.\n * @returns {Object} key-value pairs\n */\nfunction parseInfo (info) {\n  if (!info) return {}\n  var infoHash = parseKeyValue(info, '\\n', '\\t')\n  Object.keys(infoHash).forEach(function (key) {\n    var value = infoHash[key]\n    if ((typeof value === 'string') && value.indexOf(';') >= 0) {\n      if (value.indexOf('=') >= 0) {\n        value = parseKeyValue(value, ';', '=')\n      } else {\n        value = value.split(';')\n      }\n      infoHash[key] = value\n    }\n  })\n  return infoHash\n}\n\nmodule.exports = {\n  parseInfo: parseInfo\n}\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/job.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nconst as = require('../build/Release/aerospike.node')\n\nconst DEFAULT_POLL_INTERVALL = 1000\n\n/**\n * @class Job\n * @classdesc Potentially long-running background job.\n *\n * @see {@link Scan#background}\n * @see {@link Query#background}\n */\nfunction Job (client, jobID, module) {\n  this.client = client\n  this.jobID = jobID\n  this.module = module\n}\n\nJob.safeRandomJobID = function () {\n  return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)\n}\n\n/**\n * Repeatedly execute the given status function until it either indicates that\n * the job has completed or returns an error.\n *\n * @private\n */\nJob.pollUntilDone = function (statusFunction, pollInterval, callback) {\n  pollInterval = pollInterval || DEFAULT_POLL_INTERVALL\n  var timer = null\n  var callbackCalled = false\n  var poll = function () {\n    statusFunction(function (err, done) {\n      if (err || done) {\n        if (timer) {\n          clearInterval(timer)\n        }\n        if (callbackCalled === false) {\n          callback(err)\n          callbackCalled = true\n        }\n      } else if (!timer) {\n        timer = setInterval(poll, pollInterval)\n      }\n    })\n  }\n  poll()\n}\n\n/**\n * @private\n */\nJob.prototype.hasCompleted = function (info) {\n  return (info.status === as.jobStatus.COMPLETED)\n}\n\n/**\n * Fetch job info once to check if the job has completed.\n *\n * @private\n */\nJob.prototype.checkStatus = function (callback) {\n  var self = this\n  this.info(function (err, info) {\n    if (err) {\n      callback(err)\n    } else {\n      var completed = self.hasCompleted(info)\n      callback(null, completed)\n    }\n  })\n}\n\n/**\n * @function Job#info\n *\n * @summary Check the progress of a background job running on the database.\n *\n * @param {number} [pollInterval=1000] - Interval in milliseconds to use when polling the cluster nodes.\n * @param {Client~InfoPolicy} [policy] - The Info Policy to use for this operation.\n * @param {Job~infoCallback} callback - The function to call with the job info response.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n *\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *\n *   var scan = client.scan('test', 'demo')\n *   scan.background('myUdfModule', 'myUdfFunction', (error, job) => {\n *     if (error) throw error\n *     var timer = setInterval(() => {\n *       job.info((error, info) => {\n *         if (error) throw error\n *         console.info('scan status: %d (%d%% complete, %d records scanned)', info.status, info.progressPct, info.recordsRead)\n *         if (info.status === Aerospike.jobStatus.COMPLETED) {\n *           console.info('scan completed!')\n *           clearInterval(timer)\n *           client.close()\n *         }\n *       })\n *     }, 1000)\n *   })\n * })\n */\nJob.prototype.info = function (policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  }\n  this.client.sendCommand('jobInfo', [this.jobID, this.module, policy], callback)\n}\n\n/**\n * @function Job#waitUntilDone\n *\n * @summary Wait until the task has been completed.\n *\n * @param {number} [pollInterval=1000] - Interval in milliseconds to use when polling the cluster nodes.\n * @param {Job~doneCallback} callback - The function to call when the task has completed.\n */\nJob.prototype.waitUntilDone = function (pollInterval, callback) {\n  if (typeof pollInterval === 'function') {\n    callback = pollInterval\n    pollInterval = null\n  }\n  var client = this.client\n  var checkStatus = this.checkStatus.bind(this)\n  Job.pollUntilDone(checkStatus, pollInterval, function (err) {\n    client.callbackHandler(callback, err)\n  })\n}\n\n/**\n * @callback Job~doneCallback\n *\n * @summary Callback function called when a job has completed.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n */\n\n/**\n * @callback Job~infoCallback\n *\n * @summary The function called with the job info response.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n * @param {object} [info] - The job info.\n * @param {number} [info.status] - Status of the job. See {@link module:aerospike.jobStatus}.\n * @param {number} [info.progressPct] - Progress estimate for the job, as percentage.\n * @param {number} [info.recordsRead] - How many records have been processed.\n */\n\nmodule.exports = Job\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/llist.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nconst LLIST_STRACE_RE = /at LargeList\\.(\\w+) \\((.*):(\\d+):(\\d+)\\)/ // pattern for parsing a line of a stack trace\n\n// Creates a new aerospike.error object with the given error code and message.\n// The function name, file name and line number for the error are set\n// automatically by inspecting the current stack trace and looking for the last\n// LargeList function call on it.\nfunction llistError (code, message) {\n  var error = { code: code, message: message }\n  var strace = new Error().stack.split('\\n')\n  while (strace.length > 0) {\n    var line = strace.shift()\n    var match = LLIST_STRACE_RE.exec(line)\n    if (match && match[1] !== 'execute') {\n      error.func = match[1]\n      error.file = match[2]\n      error.line = match[3]\n      break\n    }\n  }\n  return error\n}\n\nfunction checkArgs (args, expArgLength) {\n  // number of arguments passed to the given function.\n  var arglength = args.length\n\n  // last argument must always be a callback.\n  // error if it is not callback type.\n  if (typeof args[arglength - 1] !== 'function') {\n    throw new Error('Callback function must be passed for this async API')\n  }\n\n  // for functions requiring fixed number of arguments\n  // this check is performed.\n  // If function does not have fixed number of arguments\n  // this check is skipped.\n  if (typeof expArgLength !== 'undefined') {\n    if (arglength !== expArgLength) {\n      var error = llistError(2, 'Invalid number of arguments')\n      var callback = args[arglength - 1]\n      callback(error, undefined)\n      return -1\n    }\n  }\n\n  return 0\n}\n\n/**\n * @class LargeList\n *\n * @classdesc Create and Manage a list within a single bin.\n *\n * For more information, please refer to the section on\n * <a href=\"http://www.aerospike.com/docs/guide/ldt_guide.html\" title=\"Aerospike Large Data Types\">&uArr;Large Data Types (LDT)</a>\n * in the Aerospike technical documentation.\n *\n * ### Large Data Types (LDT) Are Deprecated\n *\n * The Large Data Types (LDT) functionality is deprecated and\n * should no longer be used. All code that uses these interfaces should\n * transition to the List and SortedMaps APIs. Most applications can use a\n * variety of techniques such as bucketing to provide higher performance and\n * reliability using the new APIs. Please check out the\n * <a href=\"http://www.aerospike.com/docs/guide/ldt_guide.html\">&uArr;technical documentation</a>\n * for detailed information on LDT alternatives.\n *\n * The discontinuation of support for the Large Data Type (LDT) feature was\n * announced on November 14, 2016 via the following blog post:\n * <a href=\"http://www.aerospike.com/blog/aerospike-ldt/\">http://www.aerospike.com/blog/aerospike-ldt/</a>.\n *\n * @param {Key} key - The key used to locate the record in the cluster.\n * @param {string} binName - Name of the LDT bin.\n * @param {Client~ApplyPolicy} [policy] - The Apply Policy to use for this operation.\n * @param {string} [createModule] - The LUA function name that initializes the\n * list configuration parameters; pass <code>null</code> for default list.\n *\n * @deprecated since v2.4.4\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *   var key          = new Aerospike.Key('test', 'demo', 'llistKey')\n *   var binName      = 'LDTbin'\n *   var policy       = { timeout: 1000 }\n *   var createModule = 'ListInitializer'\n *   var llist = client.LargeList(key, binName, policy, createModule)\n *   // operate on large list\n *   client.close()\n * })\n *\n */\nfunction LargeList (client, key, binName, writePolicy, createModule) {\n  this.key = key\n  this.binName = binName\n  this.writePolicy = writePolicy\n  this.createModule = createModule\n  this.module = 'llist'\n\n  var self = this\n\n  // Generic function to execute any LDT function.\n  // Invokes udf execute with the corresponding LDT function name, file name as\n  // llist - file in which all the LDT functions are implemented. Some function\n  // applies an UDF/Filter on values returned by LDT. Those values are passed\n  // as {module:\" \", funcname:\" \", args: \" \"} object. Parse the above object\n  // format and populate UDFArgs accordingly. Position of the UDF arguments is\n  // passed to parse effectively.\n  this.execute = function (ldtFunc, ldtargs, arglength, udfPosition) {\n    if (typeof udfPosition === 'undefined') {\n      udfPosition = -1\n    }\n\n    if (checkArgs(ldtargs, arglength) !== 0) {\n      return -1\n    }\n    var udfargs = [this.binName]\n    for (var i = 0; i < arglength - 1; i++) {\n      if (udfPosition === i) {\n        udfargs.push(ldtargs[i].module)\n        udfargs.push(ldtargs[i].funcname)\n        udfargs.push(ldtargs[i].args)\n      } else {\n        udfargs.push(ldtargs[i])\n      }\n    }\n    udfargs.push(this.createModule)\n    var udf = {\n      module: this.module,\n      funcname: ldtFunc,\n      args: udfargs\n    }\n    var callback = ldtargs[arglength - 1]\n    client.execute(self.key, udf, self.writePolicy, callback)\n  }\n}\n\n/**\n * @function LargeList#add\n *\n * @summary Adds a single value or an array of values to an existing Large\n * List.\n *\n * @description\n *\n * The operation fails if the value's key exists and the list is configured for\n * unique keys.\n *\n * If the value is a map, the key is identified by the <code>key</code> entry.\n * Otherwise, the value is the key. If the large list does not exist, create it\n * using the specified <code>userModule</code> configuration.\n *\n * @param {(*|Array.<*>)} value - Value(s) to add\n * @param {LargeList~valueCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @deprecated since v2.4.4\n *\n * @example <caption>Adding a single value</caption>\n *\n * llist.add({'key': 'ldt_key', 'value': 'ldtvalue'}, (error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n *\n * @example <caption>Adding a list of values</caption>\n *\n * var valArray = [{'key': 'ldt_key', 'value': 'ldtvalue'}, {'key': 'ldt_array', 'value': 'ldtarrayvalue'}]\n * llist.add(valArray, (error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n */\nLargeList.prototype.add = function (value, callback) {\n  if (Array.isArray(value)) {\n    this.execute('add_all', arguments, 2)\n  } else {\n    this.execute('add', arguments, 2)\n  }\n}\n\n/**\n * @function LargeList#update\n *\n * @summary Update/add a single value or array of values depending on if the key exists or not.\n *\n * @description\n *\n * If the value is a map, the key is identified by the <code>key</code> entry.\n * Otherwise, the value is the key. If the large list does not exist, create it\n * using the specified <code>userModule</code> configuration.\n *\n * @param {(*|Array.<*>)} value - Value(s) to update\n * @param {LargeList~valueCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @deprecated since v2.4.4\n *\n * @example <caption>Updating a single value</caption>\n *\n * llist.update({'key': 'ldt_key', 'value': 'ldtupdatedvalue'}, (error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n *\n * @example <caption>Updating a list of values</caption>\n *\n * var valArray = [{'key': 'ldt_key', 'value': 'ldtupdatevalue'}, {'key': 'ldt_array', 'value': 'ldtarrayupdatedvalue'}]\n * llist.update(valArray, (error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n */\nLargeList.prototype.update = function (value, callback) {\n  if (Array.isArray(value)) {\n    this.execute('update_all', arguments, 2)\n  } else {\n    this.execute('update', arguments, 2)\n  }\n}\n\n/**\n * @function LargeList#remove\n *\n * @summary Deletes a single value or a list of values from the Large list.\n *\n * @param {(*|Array.<*>)} value - Value(s) to delete.\n * @param {LargeList~valueCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @deprecated since v2.4.4\n *\n * @example <caption>Removing a single value</caption>\n *\n * llist.remove({'key': 'ldt_key'}, (error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n *\n * @example <caption>Removing a list of values</caption>\n *\n * var valArray = [{'key': 'ldt_key'}, {'key': 'ldt_array'}]\n * llist.remove(valArray, (error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n */\nLargeList.prototype.remove = function (value, callback) {\n  if (Array.isArray(value)) {\n    this.execute('remove_all', arguments, 2)\n  } else {\n    this.execute('remove', arguments, 2)\n  }\n}\n\n/**\n * @function LargeList#removeRange\n *\n * @summary Removes values from the list between a given start and end value.\n *\n * @param {*} valBegin - Low value of the range (inclusive)\n * @param {*} valEnd - High value of the range (inclusive)\n * @param {LargeList~valueCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @deprecated since v2.4.4\n *\n * @example\n *\n * llist.remove('begin', 'end', (error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n */\nLargeList.prototype.removeRange = function (valBegin, valEnd, callback) {\n  this.execute('remove_range', arguments, 3)\n}\n\n/**\n * @function LargeList#find\n *\n * @summary Select values from the list.\n *\n * @param {*} value - Value to select\n * @param {Object} [filterArgs] - UDF arguments for specifying LUA file, function and function arguments.\n * @param {LargeList~listCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @deprecated since v2.4.4\n *\n * @example <caption>Selecting a single value</caption>\n *\n * llist.find('search_key', (error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n *\n * @example <caption>Using a filter function</caption>\n *\n * var filter = {module: 'udf_module', funcname: 'udf_function', args: ['abc', 123, 4.5]}\n * llist.find('search_key', filter, (error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n */\nLargeList.prototype.find = function find (val, filterArgs, callback) {\n  var arglength = arguments.length\n  if (arglength === 2) {\n    this.execute('find', arguments, 2)\n  } else if (arglength === 3) {\n    this.execute('find', arguments, 3, 1)\n  }\n}\n\n/**\n * @function LargeList#filter\n *\n * @summary Select values from the list and apply specified LUA filter.\n *\n * @param {Object} filterArgs - UDF arguments for specifying LUA file, function and function arguments.\n * @param {LargeList~listCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @deprecated since v2.4.4\n *\n * @example\n *\n * var udfargs = {module: 'udf_module', funcname: 'udf_function', args: ['abc', 123, 4.5]}\n * llist.filter((error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n */\nLargeList.prototype.filter = function (filterArgs, callback) {\n  this.execute('filter', arguments, 1, 0)\n}\n\n/**\n * @function LargeList#findRange\n *\n * @summary Select a range of values from the Large List.\n *\n * @param {*} valBegin - Low value of the range (inclusive)\n * @param {*} valEnd - High value of the range (inclusive)\n * @param {Object} [filterArgs] - UDF arguments for specifying LUA file, function and function arguments.\n * @param {LargeList~valueCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @deprecated since v2.4.4\n *\n * @example <caption>Finding a range of values</caption>\n *\n * llist.findRange('begin', 'end', (error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n *\n * @example <caption>Finding a range of values then applying a filter on it</caption>\n *\n * var filter = {module: 'udf_module', funcname: 'udf_function', args: ['abc', 123, 4.5]}\n * llist.findRange('begin', 'end', filter, (error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n */\nLargeList.prototype.findRange = function (valBegin, valEnd, filterArgs, callback) {\n  var arglength = arguments.length\n  if (arglength === 3) {\n    this.execute('range', arguments, 3)\n  } else if (arglength === 4) {\n    this.execute('range', arguments, 4, 2)\n  } else {\n    throw new Error('LargeList.findRange expects either 3 or 4 arguments')\n  }\n}\n\n/**\n * @function LargeList#scan\n *\n * @summary Select all the objects in the list.\n *\n * @param {LargeList~listCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @deprecated since v2.4.4\n *\n * @example\n *\n * llist.scan((error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n */\nLargeList.prototype.scan = function (callback) {\n  this.execute('scan', arguments, 1)\n}\n\n/**\n * @function LargeList#destroy\n *\n * @summary Destroy the bin containing the Large List.\n *\n * @param {LargeList~doneCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @deprecated since v2.4.4\n *\n * @example\n *\n * llist.destroy((error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n */\nLargeList.prototype.destroy = function (callback) {\n  this.execute('destroy', arguments, 1)\n}\n\n/**\n * @function LargeList#size\n *\n * @summary Retrieves the size of the list.\n *\n * @param {LargeList~valueCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @deprecated since v2.4.4\n *\n * @example\n *\n * llist.size((error, respone) => {\n *   if (error) throw error\n *   // handle success\n * })\n */\nLargeList.prototype.size = function (callback) {\n  this.execute('size', arguments, 1)\n}\n\n/**\n * @function LargeList#getConfig\n *\n * @summary Retrieves the list configuration parameters.\n *\n * @param {LargeList~valueCallback} callback - The function to call when the operation completes with the result of the operation.\n *\n * @deprecated since v2.4.4\n *\n * @example\n *\n * llist.getConfig((error, response) => {\n *   if (error) throw error\n *   // handle success\n * })\n */\nLargeList.prototype.getConfig = function (callback) {\n  this.execute('config', arguments, 1)\n}\n\n/**\n * @callback LargeList~doneCallback\n *\n * @summary Callback function called when an operation has completed.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n */\n\n/**\n * @callback LargeList~valueCallback\n *\n * @summary Callback function called when an operation has completed.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n * @param {*} response - Value returned by the UDF function.\n */\n\n/**\n * @callback LargeList~listCallback\n *\n * @summary Callback function called when an operation has completed.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n * @param {Array.<*>} list - List of entries selected.\n */\n\nmodule.exports = LargeList\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/query.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nconst Job = require('./job')\nconst Key = require('./key')\nconst RecordStream = require('./record_stream')\n\nconst assert = require('assert')\nconst util = require('util')\n\n/**\n * @class Query\n * @classdesc The query object created by calling {@link Client#query} is used\n * for executing queries on the specified namespace and set (optional). Queries\n * perform value-based searches on secondary indexes. Queries can return a set\n * of records as a {@link RecordStream} or be processed using Aeorspike UDFs\n * (user-defined functions) before returning to the client.\n *\n * For more information, please refer to the section on\n * <a href=\"http://www.aerospike.com/docs/guide/query.html\" title=\"Aerospike Queries\">&uArr;Queries</a>\n * in the Aerospike technical documentation.\n *\n * #### Filter Predicates\n *\n * Filter predicates can be applied to queries using {@link Query#where} and\n * can further limit the number of records returned. Supported filter predicates include\n *   - [equal()]{@link module:aerospike/filter.eqal}, to match on integer or string equality,\n *   - [range()]{@link module:aerospike/filter.range}, to match on an integer range,\n *   - [contains()]{@link module:aerospike/filter.contains}, to match on list/map membership,\n *   - various geospatial filters, e.g. [geoWithinRadius()]{@link module:aerospike/filter.geoWithinRadius}\n *\n * See {@link module:aerospike/filter} for a list of all supported filter predicates.\n *\n * Before a filter predicate can be applied, a secondary index needs to be\n * created on the bins which the predicate matches on. Using the Node.js\n * client, a secondary index can be created using {@link Client#createIndex}.\n *\n * Currently, a single filter predicate is supported. To do more advanced\n * filtering, you need to use a user-defined function (UDF) to process the\n * result set on the server.\n *\n * To scan _all_ the records in a given namespace and set without applying a\n * filter predicate, you can use {@link Scan} operations instead, which provide\n * more fine-grained control over execution priority, concurrency, etc.\n *\n * #### Selecting Bins\n *\n * Using {@link Query#select} it is possible to select a subset of bins which\n * should be returned by the query. If no bins are selected, then the whole\n * record will be returned.\n *\n * #### Executing a Query\n *\n * A query is executed using {@link Query#foreach}. The method returns a {@link\n * RecordStream} which emits a <code>data</code> event for each record returned\n * by the query. The query can be aborted at any time by calling\n * {@link RecordStream#abort}.\n *\n * #### Applying User-Defined Functions\n *\n * User-defined functions (UDFs) can be used to filter, transform, and\n * aggregate query results. Stream UDFs can process a stream of data by\n * defining a sequence of operations to perform. Stream UDFs perform read-only\n * operations on a collection of records. Use {@link Query#setUdf} to set the\n * UDF parameters (module name, function name and optional list of arguments)\n * before executing the query using {@link Query#foreach}.\n *\n * The feature guides on\n * <a href=\"http://www.aerospike.com/docs/guide/udf.html\">&uArr;User-Defined Functions</a> and\n * <a href=\"http://www.aerospike.com/docs/guide/stream_udf.html\">&uArr;Stream UDFs</a>\n * contain more detailed information and examples.\n *\n * #### Query Aggregation using Stream UDFs\n *\n * Use Aerospike Stream UDFs to aggregate query results using {@link\n * Query#apply}. Aggregation queries work similar to a MapReduce system and\n * return a single result value instead of stream of records. Aggregation\n * results can be basic data types (string, number, byte array) or collection\n * types (list, map).\n *\n * Please refer to the technical documentation on\n * <a href=\"http://www.aerospike.com/docs/guide/aggregation.html\">&uArr;Aggregation</a>\n * for more information.\n *\n * #### Executing Record UDFs using Background Queries\n *\n * Record UDFs perform operations on a single record such as updating records\n * based on a set of parameters. Using {@link Query#background} you can run a\n * Record UDF on the result set of a query. Queries using Records UDFs are run\n * in the background on the server and do not return the records to the client.\n *\n * For additional information please refer to the section on\n * <a href=\"http://www.aerospike.com/docs/guide/record_udf.html\">&uArr;Record UDFs</a>\n * in the Aerospike technical documentation.\n *\n * @param {Client} client - A client instance.\n * @param {string} ns - The namescape.\n * @param {string} set - The name of a set.\n * @param {object} [options] - Query parameters.\n * @param {FilterPredicate[]} [options.filters] - List of filter predicates to\n * apply to the query. See {@link Query#where}.\n * @param {string[]} [options.select] - List of bin names to select. See\n * {@link Query#select}.\n *\n * @see {@link Client#query} to create new instances of this class.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const namespace = 'test'\n * const set = 'demo'\n *\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *   var index = {\n *     ns: namespace,\n *     set: set,\n *     bin: 'tags',\n *     index: 'tags_idx',\n *     type: Aerospike.indexType.LIST,\n *     datatype: Aerospike.indexDataType.STRING\n *   }\n *   client.createIndex(index, (error, job) => {\n *     if (error) throw error\n *     job.waitUntilDone((error) => {\n *       if (error) throw error\n *\n *       var query = client.query('test', 'demo')\n *       query.select('id', 'tags')\n *       query.where(Aerospike.filter.contains('tags', 'green', Aerospike.indexType.LIST))\n *       var stream = query.foreach()\n *       stream.on('error', (error) => {\n *         console.error(error)\n *         throw error\n *       })\n *       stream.on('data', (record) => {\n *         console.info(record)\n *       })\n *       stream.on('end', () => {\n *         client.close()\n *       })\n *     })\n *   })\n * })\n */\nfunction Query (client, ns, set, options) {\n  if (typeof set === 'object') {\n    options = set\n    set = null\n  }\n  options = options || {}\n  assertValidQueryOptions(options)\n\n  this.client = client\n\n  /**\n   * Namespace to query.\n   * @member {string} Query#ns\n   */\n  this.ns = ns\n\n  /**\n   * Name of the set to query.\n   * @member {string} Query#set\n   */\n  this.set = set\n\n  /**\n   * Filters to apply to the query.\n   *\n   * *Note:* Currently, a single filter predicate is supported. To do more\n   * advanced filtering, you need to use a user-defined function (UDF) to\n   * process the result set on the server.\n   *\n   * @member {FilterPredicate[]} Query#filters\n   *\n   * @see Use {@link Query#where} to add filter predicates to a query.\n   */\n  this.filters = options.filters || []\n\n  /**\n   * List of bin names to be selected by the query. If a query specifies bins to\n   * be selected, then only those bins will be returned. If no bins are\n   * selected, then all bins will be returned.\n   *\n   * @member {string[]} Query#selected\n   *\n   * @see Use {@link Query#select} to specify the bins to select.\n   */\n  this.selected = options.select\n\n  /**\n   * User-defined function parameters to be applied to the query executed using\n   * {@link Query#foreach}.\n   *\n   * @member {Object} Query#udf\n   */\n  this.udf = options.udf\n}\n\n/**\n * @function Query#select\n *\n * @summary Specify the names of bins to be selected by the query.\n *\n * @description If a query specifies bins to be selected, then only those bins\n * will be returned. If no bins are selected, then all bins will be returned.\n *\n * @param {...string} bins - List of bin names to return.\n */\nQuery.prototype.select = function (bins) {\n  if (Array.isArray(bins)) {\n    this.selected = bins\n  } else {\n    this.selected = Array.prototype.slice.call(arguments)\n  }\n}\n\n/**\n * @function Query#where\n *\n * @summary Adds a filter predicate to the query.\n *\n * @description *Note:* Currently, a single filter predicate is supported. To\n * do more advanced filtering, you can apply a User-Defined Function (UDF) to\n * filter, transform and aggregate the query results. See {@link Query#foreach}\n * for further information.\n *\n * @param {FilterPredicate} predicate - The filter predicate to apply to the function.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *   var query = client.query('test', 'demo')\n *   // start a background job to add a new tag 'green' to all records that have the tag 'blue'\n *   query.where(Aerospike.filter.contains('tags', 'blue', Aerospike.indexType.LIST))\n *   query.background('myUdfModule', 'addTag', ['green'], (error, job) => {\n *     if (error) throw error\n *     client.close()\n *   })\n * })\n */\nQuery.prototype.where = function (predicate) {\n  this.filters = this.filters || []\n  this.filters.push(predicate)\n}\n\n/**\n * @function Query#setUdf\n *\n * @summary Set user-defined function parameters to be applied to the query.\n *\n * @param {string} udfModule - UDF module name.\n * @param {string} udfFunction - UDF function name.\n * @param {Array<*>} [udfArgs] - Arguments for the function.\n */\nQuery.prototype.setUdf = function (udfModule, udfFunction, udfArgs) {\n  this.udf = {\n    module: udfModule,\n    funcname: udfFunction,\n    args: udfArgs\n  }\n}\n\n/**\n * @function Query#foreach\n *\n * @summary Asynchronously executes the query and returns each result item\n * through the stream.\n *\n * @description\n *\n * *Applying a Stream UDF to the query results*\n *\n * A stream UDF can be applied to the query to filter, transform and aggregate\n * the query results. The UDF parameters need to be set on the query object\n * using {@link Query#setUdf} before the query is executed.\n *\n * If a UDF is applied to the query, the resulting stream will return\n * the results of the UDF stream function. Record meta data and the record keys\n * will not be returned.\n *\n * For aggregation queries that return a single result value instead of a\n * stream of values, you should use the {@link Query#apply} method instead.\n *\n * @param {Client~QueryPolicy} [policy] - The Query Policy to use for this operation.\n *\n * @returns {RecordStream}\n */\nQuery.prototype.foreach = function (policy, dataCb, errorCb, endCb) {\n  var stream = new RecordStream(this.client)\n  if (dataCb) stream.on('data', dataCb)\n  if (errorCb) stream.on('error', errorCb)\n  if (endCb) stream.on('end', endCb)\n  var cmd = this.udf ? 'queryForeach' : 'queryAsync'\n  var queryCb = function (error, record, meta, key) {\n    if (error) {\n      stream.emit('error', error)\n    } else if (record === null) {\n      stream.emit('end')\n    } else {\n      if (key) {\n        key = new Key(key.ns, key.set, key.key, key.digest)\n      }\n      stream.emit('data', record, meta, key)\n    }\n    return !stream.aborted\n  }\n  this.client.sendCommand(cmd, [this.ns, this.set, this, policy], queryCb)\n  return stream\n}\n\nQuery.prototype.execute = Query.prototype.foreach // alias for backwards compatibility\n\n/**\n * @function Query#apply\n *\n * @summary Applies a user-defined function (UDF) to aggregate the query results.\n *\n * @description The aggregation function is called on both server and client (final reduce). Therefore, the Lua script files must also reside on both server and client.\n *\n * @param {string} udfModule - UDF module name.\n * @param {string} udfFunction - UDF function name.\n * @param {Array<*>} [udfArgs] - Arguments for the function.\n * @param {Client~QueryPolicy} [policy] - The Query Policy to use for this operation.\n * @param {Query~aggregationResultCallback} callback - The function to call when the operation completes.\n */\nQuery.prototype.apply = function (udfModule, udfFunction, udfArgs, policy, callback) {\n  if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  } else if (typeof udfArgs === 'function') {\n    callback = udfArgs\n    udfArgs = null\n  }\n  this.udf = {\n    module: udfModule,\n    funcname: udfFunction,\n    args: udfArgs\n  }\n  this.client.sendCommand('queryApply', [this.ns, this.set, this, policy], callback)\n}\n\n/**\n * @function Query#background\n *\n * @summary Applies a user-defined function (UDF) on records that match the query filter.\n * Records are not returned to the client.\n *\n * @description When a background query is initiated, the client will not wait\n * for results from the database. Instead a {@link Job} instance will be\n * returned, which can be used to query the query status on the database.\n *\n * @param {string} udfModule - UDF module name.\n * @param {string} udfFunction - UDF function name.\n * @param {Array<*>} [udfArgs] - Arguments for the function.\n * @param {Client~QueryPolicy} [policy] - The Query Policy to use for this operation.\n * @param {number} [queryID] - Job ID to use for the query; will be assigned\n * randomly if zero or undefined.\n * @param {Client~jobCallback} callback - The function to call when the operation completes.\n */\nQuery.prototype.background = function (udfModule, udfFunction, udfArgs, policy, queryID, callback) {\n  if (typeof udfArgs === 'function') {\n    callback = udfArgs\n    udfArgs = null\n  } else if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  } else if (typeof queryID === 'function') {\n    callback = queryID\n    queryID = null\n  }\n  this.udf = {\n    module: udfModule,\n    funcname: udfFunction,\n    args: udfArgs\n  }\n  queryID = queryID || Job.safeRandomJobID()\n  var self = this\n  this.client.sendCommand('queryBackground', [this.ns, this.set, this, policy, queryID], function (err) {\n    var module = self.filters.length > 0 ? 'query' : 'scan'\n    var job = new Job(self.client, queryID, module)\n    callback(err, job)\n  })\n}\n\n// In the v1 client the query() method was used for both Query and Scan\n// operations. Since v2, Scan operations should use the scan() method instead.\nfunction assertValidQueryOptions (options) {\n  var scanOptions = new Set(['UDF', 'concurrent', 'percentage', 'nobins', 'priority'])\n  var invalid = Object.keys(options).filter(function (key) {\n    return scanOptions.has(key)\n  })\n  assert(invalid.length === 0, util.format('Invalid query arguments: %s. Use Client#scan instead.', invalid.toString()))\n  assert(!options.aggregationUDF, 'Invalid query arguments: Pass UDF params to Query#apply instead.')\n}\n\n/**\n * @callback Query~aggregationResultCallback\n *\n * @summary Callback function returning the aggregation result for a query.\n *\n * @description\n *\n * If the operation was successful, <code>null</code> will be returned for the\n * error parameter. If there was an error, <code>result</code> will be\n * <code>undefined</code> and the <code>error</code> paramter will provide more\n * information about the error.\n *\n * @param {?AerospikeError} error - The error code and message or <code>null</code> if the operation was successful.\n * @param {(number|string|Array<*>|Object)} [result] - The aggregation result.\n */\n\nmodule.exports = Query\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/key.js":"/**\n * @class Key\n *\n * @summary A key uniquely identifies a record in the Aerospike database within a given namespace.\n *\n * @description\n *\n * ###### Key Digests\n * In your application, you must specify the namespace, set and the key itself\n * to read and write records. When a key is sent to the database, the key value\n * and its set are hashed into a 160-bit digest. When a database operation\n * returns a key (e.g. Query or Scan operations) it might contain either the\n * set and key value, or just the digest.\n *\n * @param {string} ns - The Namespace to which the key belongs.\n * @param {string} set - The Set to which the key belongs.\n * @param {(string|number|Buffer)} key - The unique key value. Keys can be\n * strings, integers or an instance of the Buffer class.\n *\n * @example <caption>Creating a new {@link Key} instance</caption>\n *\n * const Aerospike = require('aerospike')\n * const Key = Aerospike.Key\n *\n * var key1 = new Key('test', 'demo', 12345)\n * var key2 = new Key('test', 'demo', 'abcde')\n * var key3 = new Key('test', 'demo', Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]))\n */\nfunction Key (ns, set, key, digest) {\n  /** @member {string} Key#ns */\n  if (!isValidNamespace(ns)) {\n    throw new TypeError('Namespace must be a valid string (max. length 32)')\n  }\n  this.ns = ns\n\n  /** @member {string} [Key#set] */\n  if (isSet(set) && !isValidSetName(set)) {\n    throw new TypeError('Set must be a valid string (max. length 64)')\n  }\n  this.set = set\n\n  /** @member {(string|integer|Buffer)} [Key#key] */\n  var hasKey = isSet(key)\n  if (hasKey && !isValidKey(key)) {\n    throw new TypeError('Key must be a string, integer, or Buffer')\n  }\n  this.key = key\n\n  /**\n   * @member {Buffer} [Key#digest]\n   *\n   * @summary The 160-bit digest used by the Aerospike server to uniquely\n   * identify a record within a namespace.\n   */\n  var hasDigest = isSet(digest)\n  if (hasDigest && !isValidDigest(digest)) {\n    throw new TypeError('Digest must be a 20-byte Buffer')\n  }\n  this.digest = digest || null\n\n  if (!(hasKey || hasDigest)) {\n    throw new TypeError('Either key or digest must be set')\n  }\n}\n\nfunction isSet (value) {\n  return typeof value !== 'undefined' && value !== null\n}\n\nfunction isValidNamespace (ns) {\n  return (typeof ns === 'string') &&\n    (ns.length > 0) &&\n    (ns.length <= 32)\n}\n\nfunction isValidSetName (set) {\n  return (typeof set === 'string') &&\n    (set.length > 0) &&\n    (set.length <= 64)\n}\n\nfunction isValidKey (key) {\n  return (typeof key === 'string' && key.length > 0) ||\n    (Number.isInteger(key)) ||\n    (Buffer.isBuffer(key) && Buffer.byteLength(key) > 0)\n}\n\nfunction isValidDigest (digest) {\n  return (Buffer.isBuffer(digest) && digest.length === 20)\n}\n\nmodule.exports = Key\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/record_stream.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nconst stream = require('stream')\nconst inherits = require('util').inherits\n\n/**\n * @class RecordStream\n * @classdesc Stream of database records (full or partial) returned by {@link Query} or {@link Scan} operations.\n *\n * *Note:* Record stream currently does not support Node.js'\n * <code>Stream#pause</code> and <code>Stream#resume</code> methods, i.e. it\n * always operates in flowing mode. That means data is read from the Aerospike\n * database and provided to your application as fast as possible. If no data\n * event handlers are attached, then data will be lost.\n *\n * #### Aborting a Query/Scan\n *\n * A query or scan operation can be aborted by calling the {@link\n * RecordStream#abort} method at any time. It is no possible to continue a\n * record stream, once aborted.\n *\n * @extends stream\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *   var recordsSeen = 0\n *   var scan = client.scan('test', 'demo')\n *   var stream = scan.foreach()\n *\n *   stream.on('error', (error) => {\n *     console.error(error)\n *     throw error\n *   })\n *   stream.on('data', (record) => {\n *     recordsSeen++\n *     console.log(record)\n *     if (recordsSeen > 1000) {\n *       stream.abort() // We've seen enough!\n *     }\n *   })\n *   stream.on('end', () => {\n *     console.info(stream.aborted ? 'scan aborted' : 'scan completed')\n *     client.close()\n *   })\n * })\n */\nfunction RecordStream (client) {\n  /**\n   * <code>true</code> if the scan has been aborted by the user; <code>false</code> otherwise.\n   * @member {boolean} RecordStream#aborted\n   * @see {@link RecordStream#abort}\n   */\n  this.aborted = false\n\n  // Keep a reference to the client instance even though it's not actually\n  // needed to process the stream. This is to prevent situations where the\n  // client object goes out of scope while the stream is still being processed\n  // and the memory for the C++ client instance and dependent objects gets\n  // free'd.\n  this.client = client\n}\n\ninherits(RecordStream, stream)\n\nRecordStream.prototype.writable = false\nRecordStream.prototype.readable = true\nRecordStream.prototype._read = function () {}\n\n/**\n * @function RecordStream#abort\n *\n * @summary Aborts the query/scan operation.\n *\n * Once aborted, it is not possible to resume the stream.\n *\n * @since v2.0\n */\nRecordStream.prototype.abort = function () {\n  if (this.aborted) return\n  this.aborted = true\n  process.nextTick(this.emit.bind(this, 'end'))\n}\n\n/**\n * @event RecordStream#data\n * @param {?object} bins - The record bins; may be <code>null</code> if {@link Scan#nobins} is used.\n * @param {?object} meta - Record meta data, e.g. ttl, generation, etc.\n * @param {?Key} key - The record's key. By default the server only stores the\n * key digest unless <code>Aerospike.policy.key.SEND</code> is used; so the\n * <code>key</code> property of the returned Key object might be\n * undefined and only <code>digest</code> will be populated.\n */\n\n/**\n * @event RecordStream#error\n * @type {AerospikeError}\n */\n\n/**\n * @event RecordStream#end\n */\n\nmodule.exports = RecordStream\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/scan.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nconst Job = require('./job')\nconst Key = require('./key')\nconst RecordStream = require('./record_stream')\n\n/**\n * @class Scan\n * @classdesc The scan object created by calling {@link Client#scan} is used\n * for executing record scans on the specified namespace and set (optional).\n * Scans can return a set of records as a {@link RecordStream} or apply an\n * Aerospike UDF (user-defined function) on each of the records on the server.\n *\n * For more information, please refer to the section on\n * <a href=\"http://www.aerospike.com/docs/guide/scan.html\">&uArr;Scans</a>\n * in the Aerospike technical documentation.\n *\n * #### Selecting Bins\n *\n * Using {@link Scan#select} it is possible to select a subset of bins which\n * should be returned by the query. If no bins are selected, then the whole\n * record will be returned. If the {@link Scan#nobins} property is set to\n * <code>true</code> the only the record meta data (ttl, generation, etc.) will\n * be returned.\n *\n * #### Executing a Scan\n *\n * A scan is executed using {@link Scan#foreach}. The method returns a {@link\n * RecordStream} which emits a <code>data</code> event for each record returned\n * by the scan. The scan can be aborted at any time by calling\n * {@link RecordStream#abort}.\n *\n * #### Executing Record UDFs using Background Scans\n *\n * Record UDFs perform operations on a single record such as updating records\n * based on a set of parameters. Using {@link Scan#background} you can run a\n * Record UDF on the result set of a scan. Scans using Records UDFs are run\n * in the background on the server and do not return the records to the client.\n *\n * For additional information please refer to the section on\n * <a href=\"http://www.aerospike.com/docs/guide/record_udf.html\">&uArr;Record UDFs</a>\n * in the Aerospike technical documentation.\n *\n * @param {Client} client - A client instance.\n * @param {string} ns - The namescape.\n * @param {string} set - The name of a set.\n * @param {object} [options] - Scan parameters.\n * @param {Array<string>} [options.select] - List of bin names to select. See\n * {@link Scan#select}.\n * @param {number} [options.priority] - Priority level at which the scan will\n * be executed. See {@link Scan#priority}.\n * @param {number} [options.percent=100] - Percentage of records to scan. See\n * {@link Scan#percent}.\n * @param {boolean} [options.nobins=false] - Whether only meta data should be\n * returned. See {@link Scan#nobins}.\n * @param {boolean} [options.concurrent=false] - Whether all cluster nodes\n * should be scanned concurrently. See {@link Scan#concurrent}.\n *\n * @see {@link Client#scan} to create new instances of this class.\n *\n * @since v2.0\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n *\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *\n *   var scan = client.scan('test', 'demo')\n *   scan.priority = Aerospike.scanPriority.LOW\n *   scan.percent = 50 // scan only 50% of all records in the set\n *\n *   var recordsSeen = 0\n *   var stream = scan.foreach()\n *   stream.on('error', (error) => { throw error })\n *   stream.on('end', () => client.close())\n *   stream.on('data', (record) => {\n *     console.log(record)\n *     recordsSeen++\n *     if (recordsSeen > 100) stream.abort() // We've seen enough!\n *   })\n * })\n */\nfunction Scan (client, ns, set, options) {\n  if (typeof set === 'object') {\n    options = set\n    set = null\n  }\n\n  this.client = client\n\n  /**\n   * Namespace to scan.\n   * @member {string} Scan#ns\n   */\n  this.ns = ns\n\n  /**\n   * Name of the set to scan.\n   * @member {string} Scan#set\n   */\n  this.set = set\n\n  /**\n   * List of bin names to be selected by the scan. If a scan specifies bins to\n   * be selected, then only those bins will be returned. If no bins are\n   * selected, then all bins will be returned (unless {@link Scan#nobins} is\n   * set to <code>true</code>).\n   *\n   * @member {string[]} Scan#selected\n   *\n   * @see Use {@link Scan#select} to specify the bins to select.\n   */\n  this.selected = options.select\n\n  /**\n   * Priority level at which the scan will be executed.\n   *\n   * @member {number} Scan#priority\n   *\n   * @see {@link module:aerospike.scanPriority} for enumeration of allowed values.\n   */\n  this.priority = options.priority\n\n  /**\n   * Percentage of records in the cluster to scan.\n   *\n   * @member {number} Scan#percent\n   */\n  this.percent = options.percent\n\n  /**\n   * If set to <code>true</code>, the scan will return only meta data, and exclude bins.\n   *\n   * @member {boolean} Scan#nobins\n   */\n  this.nobins = options.nobins\n\n  /**\n   * If set to <code>true</code>, all cluster nodes will be scanned in parallel.\n   *\n   * @member {boolean} Scan#concurrent.\n   */\n  this.concurrent = options.concurrent\n}\n\n/**\n * @function Scan#select\n *\n * @summary Specify the names of bins to be selected by the scan.\n *\n * If a scan specifies bins to be selected, then only those bins will be\n * returned. If no bins are selected, then all bins will be returned. (Unless\n * {@link Scan#nobins} is set to <code>true</code>.)\n *\n * @param {...string} bins - List of bin names to return.\n */\nScan.prototype.select = function (bins) {\n  if (Array.isArray(bins)) {\n    this.selected = bins\n  } else {\n    this.selected = Array.prototype.slice.call(arguments)\n  }\n}\n\n/**\n * @function Scan#background\n *\n * @summary Perform a read-write background scan and apply a Lua user-defined\n * function (UDF) to each record.\n *\n * @description When a background scan is initiated, the client will not wait\n * for results from the database. Instead a {@link Job} instance will be\n * returned, which can be used to query the scan status on the database.\n *\n * @param {string} udfModule - UDF module name.\n * @param {string} udfFunction - UDF function name.\n * @param {Array<*>} [udfArgs] - Arguments for the function.\n * @param {Client~ScanPolicy} [policy] - The Scan Policy to use for this operation.\n * @param {number} [scanID] - Job ID to use for the scan; will be assigned\n * randomly if zero or undefined.\n * @param {Client~jobCallback} callback - The function to call when the operation completes.\n */\nScan.prototype.background = function (udfModule, udfFunction, udfArgs, policy, scanID, callback) {\n  if (typeof udfArgs === 'function') {\n    callback = udfArgs\n    udfArgs = null\n  } else if (typeof policy === 'function') {\n    callback = policy\n    policy = null\n  } else if (typeof scanID === 'function') {\n    callback = scanID\n    scanID = null\n  } else if (typeof callback !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function')\n  }\n  this.udf = {\n    module: udfModule,\n    funcname: udfFunction,\n    args: udfArgs\n  }\n  scanID = scanID || Job.safeRandomJobID()\n  var self = this\n  this.client.sendCommand('scanBackground', [this.ns, this.set, this, policy, scanID], function (err) {\n    var job = new Job(self.client, scanID, 'scan')\n    callback(err, job)\n  })\n}\n\n/**\n * @function Scan#foreach\n *\n * @summary Performs a read-only scan on each node in the cluster. As the scan\n * iterates through each partition, it returns the current version of each\n * record to the client.\n *\n * @param {Client~ScanPolicy} [policy] - The Scan Policy to use for this operation.\n *\n * @returns {RecordStream}\n */\nScan.prototype.foreach = function (policy, dataCb, errorCb, endCb) {\n  if (this.udf) throw new Error('Record UDF can only be applied using background scan.')\n  var stream = new RecordStream(this.client)\n  if (dataCb) stream.on('data', dataCb)\n  if (errorCb) stream.on('error', errorCb)\n  if (endCb) stream.on('end', endCb)\n  var scanID = Job.safeRandomJobID()\n  var scanCb = function (error, record, meta, key) {\n    if (error) {\n      stream.emit('error', error)\n    } else if (record === null) {\n      stream.emit('end')\n    } else {\n      if (key) {\n        key = new Key(key.ns, key.set, key.key, key.digest)\n      }\n      stream.emit('data', record, meta, key)\n    }\n    return !stream.aborted\n  }\n  this.client.sendCommand('scanAsync', [this.ns, this.set, this, policy, scanID], scanCb)\n  stream.job = new Job(this.client, scanID, 'scan')\n  return stream\n}\n\nScan.prototype.execute = Scan.prototype.foreach // alias for backwards compatibility\n\nmodule.exports = Scan\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/event_loop.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nconst as = require('../build/Release/aerospike.node')\n\n/**\n * Whether event loop resources have been released\n *\n * @type {boolean}\n * @private\n */\nvar _eventLoopReleased = false\n\n/**\n * Whether event loop resources have been created\n *\n * @type {boolean}\n * @private\n */\nvar _eventLoopInitialized = false\n\n/**\n * @memberof! module:aerospike\n *\n * @summary Release event loop resources.\n *\n * @description This method releases the event loop resources held by the\n * Aerospike C client library. It is normally called automatically when the\n * Aerospike Node.js client instance is closed. However, when the application\n * needs to create multiple client instances, then `releaseEventLoop = false`\n * needs to be passed in the {@link Client#close} method and the event loop\n * resources need to be released explicitly by calling this method.\n *\n * @example <caption>Working with multiple client instances.</caption>\n *\n * const Aerospike = require('aerospike')\n *\n * // called one or more times to handle a new work request\n * function handleRequest (request) {\n *   Aerospike.connect(function (err, client) {\n *     if (err) {\n *       // handle error\n *     }\n *     // handle request\n *     client.close(false) // do not release event loop\n *   })\n * }\n *\n * // called when application shuts down\n * function shutdown () {\n *   Aerospike.releaseEventLoop()\n * }\n */\nfunction releaseEventLoop () {\n  _eventLoopReleased = true\n  if (as.get_cluster_count() > 0) {\n    setTimeout(releaseEventLoop, 5)\n  } else {\n    as.release_as_event_loop()\n  }\n}\n\n/**\n * @private\n */\nfunction eventLoopReleased () {\n  return _eventLoopReleased\n}\n\n/**\n * @private\n */\nfunction registerASEventLoop () {\n  if (!_eventLoopInitialized) {\n    as.register_as_event_loop()\n    _eventLoopInitialized = true\n  }\n}\n\nmodule.exports = {\n  releaseEventLoop: releaseEventLoop,\n  eventLoopReleased: eventLoopReleased,\n  registerASEventLoop: registerASEventLoop\n}\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/operations.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n/**\n * @module aerospike/operations\n *\n * @description This module provides functions to easily define operations to\n * be performed on a record via the {@link Client#operate} command.\n *\n * @see {@link Client#operate}\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const op = Aerospike.operations\n * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n *\n * var ops = [\n *   op.append('a', 'xyz'),\n *   op.incr('b', 10),\n *   op.read('b')\n * ]\n *\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *   client.put(key, { a: 'abc', b: 42 }, (error) => {\n *     if (error) throw error\n *     client.operate(key, ops, (error, record) => {\n *       if (error) throw error\n *       console.log(record) // => { b: 52 }\n *       client.close()\n *     })\n *   })\n * })\n */\n\nconst as = require('../build/Release/aerospike.node')\nconst ops = as.operations\n\n/**\n * @private\n */\nfunction Operation (op, bin) {\n  this.op = op\n  this.bin = bin\n}\n\nmodule.exports = {\n\n  /**\n   * @summary Read the value of the bin.\n   *\n   * @param {string} bin - The name of the bin.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  read: function read (bin) {\n    return new Operation(ops.READ, bin)\n  },\n\n  /**\n   * @summary Update the value of the bin.\n   *\n   * @param {string} bin - The name of the bin.\n   * @param {any} value - The value to set the bin to.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  write: function write (bin, value) {\n    var op = new Operation(ops.WRITE, bin)\n    op.value = value\n    return op\n  },\n\n  /**\n   * @summary Increment the value of the bin by the given value.\n   *\n   * @description The bin must contain either an Integer or a Double, and the\n   * value must be of the same type.\n   *\n   * @param {string} bin - The name of the bin.\n   * @param {(number|Double)} value - The value to increment the bin by.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  incr: function incr (bin, value) {\n    var op = new Operation(ops.INCR, bin)\n    op.value = value\n    return op\n  },\n\n  /**\n   * @summary Append the value to the bin.\n   *\n   * @description The bin must contain either String or a Byte Array, and the\n   * value must be of the same type.\n   *\n   * @param {string} bin - The name of the bin.\n   * @param {(string|Buffer)} value - The value to append to the bin.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  append: function append (bin, value) {\n    var op = new Operation(ops.APPEND, bin)\n    op.value = value\n    return op\n  },\n\n  /**\n   * @summary Prepend the value to the bin.\n   *\n   * @description The bin must contain either String or a Byte Array, and the\n   * value must be of the same type.\n   *\n   * @param {string} bin - The name of the bin.\n   * @param {(string|Buffer)} value - The value to prepend to the bin.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  prepend: function prepend (bin, value) {\n    var op = new Operation(ops.PREPEND, bin)\n    op.value = value\n    return op\n  },\n\n  /**\n   * @summary Update the TTL (time-to-live) for a record.\n   *\n   * @description If the optional `ttl` parameter is not specified, the server\n   * will reset the record's TTL value to the default TTL value for the\n   * namespace.\n   *\n   * @param {number} [ttl=Aerospike.ttl.NAMESPACE_DEFAULT] - The new, relative TTL to set for the record, when it is touched.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @see {@link module:aerospike.ttl} for \"special\" TTL values.\n   */\n  touch: function touch (ttl) {\n    var op = new Operation(ops.TOUCH)\n    op.ttl = ttl\n    return op\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/utils.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nconst HOST_RE = /^(\\[[0-9a-f:]+]|(?:\\d{1,3}\\.){3}\\d{1,3}|[a-z][a-z0-9\\-.]+)(?::([a-z][a-z0-9\\-.]+))?(?::(\\d+))?$/i\n\nfunction parseHostString (hostString) {\n  var parts = hostString.match(HOST_RE)\n  if (!parts) {\n    throw new Error('Invalid host address: ' + hostString)\n  }\n  var host = {}\n  host.addr = parts[1]\n  var tlsName = parts[2]\n  if (tlsName) {\n    host.tls = tlsName\n  }\n  var port = parts[3]\n  host.port = port ? Number.parseInt(port, 10) : 3000\n  return host\n}\n\nfunction parseHostsString (str) {\n  return str\n      .split(',')\n      .map(function (str) { return str.trim() })\n      .filter(function (x) { return !!x })\n      .map(parseHostString)\n}\n\nfunction print (err, results) {\n  if (err) {\n    console.error(err.message)\n  } else {\n    results = Array.from(arguments)\n      .slice(1)\n      .filter(function (elem) {\n        return typeof elem !== 'undefined'\n      })\n    console.info.apply(null, ['Response: '].concat(results))\n  }\n}\n\nfunction kvlistToMap (kvList, MapConstructor) {\n  MapConstructor = MapConstructor || Map\n  var map = new MapConstructor()\n  for (var i = 0; i < kvList.length; i = i + 2) {\n    var key = kvList[i]\n    var value = kvList[i + 1]\n    map.set(key, value)\n  }\n  return map\n}\n\nmodule.exports = {\n  parseHostString: parseHostString,\n  parseHostsString: parseHostsString,\n  print: print,\n  kvlistToMap: kvlistToMap\n}\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/double.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n/**\n * @class Double\n *\n * @classdesc All the decimal values with valid fractions (e.g. 123.45) will be\n * stored as double data type in aerospike. To store decimal values with 0\n * fraction as double, the value needs to be wrapped in a `Double` class\n * instance\n *\n * @summary Creates a new Double instance.\n *\n * @description Note: The use of the `Double` function without the `new`\n * keyword is deprecated in version 2.0.\n *\n * @param {number} value - The value of the double.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const Double = Aerospike.Double\n * const client = Aerospike.client().connect((error) => {\n *   if (error) throw error\n * })\n * const key = new Aerospike.Key('test', 'demo', 'myDouble')\n *\n * var record = { d: 3.1415 }\n * client.put(key, record, (error) => {\n *   if (error) throw error\n * })\n *\n * function incr (value) {\n *   // wrap value in Double since we can't be sure it would be converted to\n *   // double automatically, e.g. 1.0\n *   client.operate(key, [Aerospike.operations.incr('d', new Double(value))], (error) => {\n *     if (error) throw error\n *   })\n * }\n *\n * incr(6.283)\n * incr(1.0)\n *\n * client.get(key, (error, record) => {\n *   console.log(record)\n *   client.close()\n * })\n */\nfunction Double (value) {\n  if (this instanceof Double) {\n    this.Double = parseFloat(value)\n    if (isNaN(this.Double)) {\n      throw new TypeError('Not a valid Double value')\n    }\n  } else {\n    return new Double(value)\n  }\n}\n\n/**\n * @function Double#value\n *\n * @return {number} value of the Double\n */\nDouble.prototype.value = function () {\n  return this.Double\n}\n\nmodule.exports = Double\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/geojson.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n/**\n * @class GeoJSON\n *\n * @classdesc Representation of a GeoJSON value. Since GeoJSON values are JSON\n * objects they need to be wrapped in the <code>GeoJSON</code> class so that\n * the client can distinguish them from other types of objects.\n *\n * For more information, please refer to the section on\n * <a href=\"http://www.aerospike.com/docs/guide/geospatial.html\" title=\"Aerospike Geospatial Data Type\">&uArr;Geospatial Data Type</a>\n * in the Aerospike technical documentation.\n *\n * @summary Creates a new GeoJSON instance.\n *\n * @param {(Object|string)} value - GeoJSON value; the constructor accepts\n * either a string representation of the JSON object, or a JS object.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const GeoJSON = Aerospike.GeoJSON\n * const Key = Aerospike.Key\n *\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *   var key = new Key('test', 'demo', 'bob')\n *   var location = new GeoJSON({type: 'Point', coordinates: [103.913, 1.308]})\n *   client.put(key, {loc: location}, (error) => {\n *     if (error) throw error\n *     client.close()\n *   })\n * })\n *\n */\nfunction GeoJSON (json) {\n  if (this instanceof GeoJSON) {\n    switch (typeof json) {\n      case 'string':\n        this.str = json\n        break\n      case 'object':\n        this.str = JSON.stringify(json)\n        break\n      default:\n        throw new TypeError('Not a valid GeoJSON value')\n    }\n  } else {\n    return new GeoJSON(json)\n  }\n}\n\n/**\n * @function GeoJSON.Point\n *\n * @summary Helper function to create a new GeoJSON object representing the\n * point with the given coordinates.\n *\n * @param {number} lng - Longitude\n * @param {number} lat - Latitude\n * @returns {GeoJSON} a GeoJSON representation of the point\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const GeoJSON = Aerospike.GeoJSON\n *\n * var point = GeoJSON.Point(103.913, 1.308)\n */\nGeoJSON.Point = function (lng, lat) {\n  return new GeoJSON({type: 'Point', coordinates: [lng, lat]})\n}\n\n/**\n * @function GeoJSON.Polygon\n *\n * @summary Helper function to create a new GeoJSON object representing the\n * polygon with the given coordinates.\n *\n * @param {...number[]} coordinates - one or more coordinate pairs (lng, lat)\n * describing the polygon.\n * @returns {GeoJSON} a GeoJSON representation of the polygon.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const GeoJSON = Aerospike.GeoJSON\n *\n * var polygon = GeoJSON.Polygon([102.913, 0.308], [102.913, 2.308], [104.913, 2.308], [104.913, 0.308], [102.913, 0.308])\n */\nGeoJSON.Polygon = function (coordinates) {\n  coordinates = Array.prototype.slice.call(arguments)\n  return new GeoJSON({type: 'Polygon', coordinates: [coordinates]})\n}\n\n/**\n * Returns the GeoJSON value as a JS object.\n *\n * @return {Object}\n */\nGeoJSON.prototype.toJSON = function () {\n  return JSON.parse(this.str)\n}\n\n/**\n * Returns the GeoJSON value as a string\n *\n * @return {string}\n */\nGeoJSON.prototype.toString = function () {\n  return this.str\n}\n\n/**\n * Alias for {@link GeoJSON#toJSON}. Returns the GeoJSON value as a JS object.\n *\n * @return {Object}\n */\nGeoJSON.prototype.value = function () {\n  return this.toJSON()\n}\n\nmodule.exports = GeoJSON\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/filter.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n// Defining this before the @module so that it's not included in the module.\n/**\n * @class FilterPredicate\n * @classdesc Filter predicate to limit the scope of a {@link Query}.\n *\n * Filter predicates must be instantiated using the methods in the {@link\n * module:aerospike/filter} module.\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *\n *   // find any records that have a recent location within 1000m radius of the specified coordinates\n *   var statement = {\n *     filters: [ Aerospike.filter.geoWithinRadius('recent', 103.8, 1.305, 1000, Aerospike.indexType.LIST) ]\n *   }\n *   var query = client.query('test', 'demo', statement)\n *\n *   var stream = query.execute()\n *   stream.on('error', (error) => { throw error })\n *   stream.on('data', (record) => console.log(record.bins.recent))\n *   stream.on('end', () => client.close())\n * })\n *\n */\nfunction FilterPredicate (predicate, bin, dataType, indexType) {\n  this.predicate = predicate\n  this.bin = bin\n  this.datatype = dataType\n  this.type = indexType || as.indexType.DEFAULT\n}\n\n/**\n * @module aerospike/filter\n *\n * @description This module provides function to specify filter predicates for\n * use in query operations via the {@link Client#query} command.\n *\n * **Note:** Currently, queries only support a single filter predicate. To do\n * more advanced filtering, you can use a UDF to process the result set on the\n * server.\n *\n * @see {@link Query}\n */\n\nconst as = require('../build/Release/aerospike.node')\nconst GeoJSON = require('./geojson')\n\nconst util = require('util')\n\n// Helper function to determine the type of a primitive or Object\nfunction typeOf (value) {\n  if (value === null) return 'null'\n  var valueType = typeof value\n  if (valueType === 'object') {\n    valueType = value.constructor.name.toLowerCase()\n  }\n  return valueType\n}\n\nfunction dataTypeOf (value) {\n  switch (typeOf(value)) {\n    case 'string':\n      return as.indexDataType.STRING\n    case 'number':\n    case 'double':\n      return as.indexDataType.NUMERIC\n    default:\n      throw new TypeError('Unknown data type for filter value.')\n  }\n}\n\nfunction EqualPredicate (bin, value, dataType, indexType) {\n  FilterPredicate.call(this, as.predicates.EQUAL, bin, dataType, indexType)\n  this.val = value\n}\nutil.inherits(EqualPredicate, FilterPredicate)\n\nfunction RangePredicate (bin, min, max, dataType, indexType) {\n  FilterPredicate.call(this, as.predicates.RANGE, bin, dataType, indexType)\n  this.min = min\n  this.max = max\n}\nutil.inherits(RangePredicate, FilterPredicate)\n\nfunction GeoPredicate (bin, value, indexType) {\n  FilterPredicate.call(this, as.predicates.RANGE, bin, as.indexDataType.GEO2DSPHERE, indexType)\n  this.val = value\n}\nutil.inherits(GeoPredicate, FilterPredicate)\n\nfunction equalFilter (bin, value) {\n  var dataType = dataTypeOf(value)\n  return new EqualPredicate(bin, value, dataType)\n}\n\nfunction rangeFilter (bin, min, max, indexType) {\n  var dataType = as.indexDataType.NUMERIC\n  return new RangePredicate(bin, min, max, dataType, indexType)\n}\n\nfunction containsFilter (bin, value, indexType) {\n  var dataType = dataTypeOf(value)\n  return new EqualPredicate(bin, value, dataType, indexType)\n}\n\nfunction geoJSONFilter (bin, value, indexType) {\n  if (value instanceof GeoJSON) {\n    value = value.toString()\n  } else if (typeof value === 'object') {\n    value = JSON.stringify(value)\n  }\n  return new GeoPredicate(bin, value, indexType)\n}\n\nfunction geoWithinRadiusFilter (bin, lon, lat, radius, indexType) {\n  var value = new GeoJSON({type: 'AeroCircle', coordinates: [[lon, lat], radius]})\n  return new GeoPredicate(bin, value.toString(), indexType)\n}\n\nfunction geoContainsPointFilter (bin, lon, lat, indexType) {\n  var value = new GeoJSON({type: 'Point', coordinates: [lon, lat]})\n  return new GeoPredicate(bin, value.toString(), indexType)\n}\n\nmodule.exports = {\n  /**\n   * @function equal\n   * @static\n   *\n   * String/integer equality filter. The filter matches records with a bin that\n   * matches a specified string or integer value.\n   *\n   * @param {string} bin - The name of the bin.\n   * @param {string} value - The filter value.\n   * @returns {FilterPredicate} Filter predicate that can be passed to the {@link Client#query} command.\n   */\n  equal: equalFilter,\n\n  /**\n   * @function contains\n   * @static\n   *\n   * Filter for list/map membership. The filter matches records with a bin that\n   * has a list or map value that contain the given string or integer.\n   *\n   * @param {string} bin - The name of the bin.\n   * @param {(string|integer)} value - The value that should be a member of the\n   * list or map in the bin.\n   * @param {number} indexType - One of {@link module:aerospike.indexType},\n   * i.e. LIST, MAPVALUES or MAPKEYS.\n   * @returns {FilterPredicate} Filter predicate that can be passed to the {@link Client#query} command.\n   *\n   * @since v2.0\n   */\n  contains: containsFilter,\n\n  /**\n   * @function range\n   * @static\n   *\n   * Integer range filter. The filter matches records with a bin value in the\n   * given integer range. The filter can also be used to match for integer\n   * values within the given range that are contained with a list or map by\n   * specifying the appropriate index type.\n   *\n   * @param {string} bin - The name of the bin.\n   * @param {number} min - Lower end of the range (inclusive).\n   * @param {number} max - Upper end of the range (inclusive).\n   * @param {number} [indexType=Aerospike.indexType.DEFAULT] - One of {@link\n   * module:aerospike.indexType}, i.e. LIST or MAPVALUES.\n   * @returns {FilterPredicate} Filter predicate that can be passed to the {@link Client#query} command.\n   */\n  range: rangeFilter,\n\n  /**\n   * @function geoWithin\n   * @static\n   *\n   * @deprecated since v2.0 - use geoWithinGeoJSONRegion() instead.\n   */\n  geoWithin: geoJSONFilter,\n\n  /**\n   * @function geoWithinGeoJSONRegion\n   * @static\n   *\n   * Geospatial filter that matches points within a given GeoJSON region.\n   * Depending on the index type, the filter will match GeoJSON values\n   * contained in list or map values as well (requires Aerospike server\n   * version >= 3.8).\n   *\n   * @param {string} bin - The name of the bin.\n   * @param {GeoJSON} value - GeoJSON region value.\n   * @param {number} [indexType=Aerospike.indexType.DEFAULT] - One of {@link\n   * module:aerospike.indexType}, i.e. LIST or MAPVALUES.\n   * @returns {FilterPredicate} Filter predicate that can be passed to the {@link Client#query} command.\n   *\n   * @since v2.0\n   */\n  geoWithinGeoJSONRegion: geoJSONFilter,\n\n  /**\n   * @function geoWithinRadius\n   * @static\n   *\n   * Geospatial filter that matches points within a radius from a given point.\n   * Depending on the index type, the filter will match GeoJSON values\n   * contained in list or map values as well (requires Aerospike server\n   * version >= 3.8).\n   *\n   * @param {string} bin - The name of the bin.\n   * @param {number} lng - Longitude of the center point.\n   * @param {number} lat - Latitude of the center point.\n   * @param {number} radius - Radius in meters.\n   * @param {number} [indexType=Aerospike.indexType.DEFAULT] - One of {@link\n   * module:aerospike.indexType}, i.e. LIST or MAPVALUES.\n   * @returns {FilterPredicate} Filter predicate that can be passed to the {@link Client#query} command.\n   *\n   * @since v2.0\n   */\n  geoWithinRadius: geoWithinRadiusFilter,\n\n  /**\n   * @function geoContains\n   * @static\n   *\n   * @deprecated since v2.0 - use geoContainsGeoJSONPoint() instead.\n   */\n  geoContains: geoJSONFilter,\n\n  /**\n   * @function geoContainsGeoJSONPoint\n   * @static\n   *\n   * Geospatial filter that matches regions that contain a given GeoJSON point.\n   * Depending on the index type, the filter will match GeoJSON regions within\n   * list or map values as well (requires Aerospike server version >= 3.8).\n   *\n   * @param {string} bin - The name of the bin.\n   * @param {GeoJSON} value - GeoJSON point value.\n   * @param {number} [indexType=Aerospike.indexType.DEFAULT] - One of {@link\n   * module:aerospike.indexType}, i.e. LIST or MAPVALUES.\n   * @returns {FilterPredicate} Filter predicate that can be passed to the {@link Client#query} command.\n   *\n   * @since v2.0\n   */\n  geoContainsGeoJSONPoint: geoJSONFilter,\n\n  /**\n   * @function geoContainsPoint\n   * @static\n   *\n   * Geospatial filter that matches regions that contain a given lng/lat\n   * coordinate. Depending on the index type, the filter will match GeoJSON\n   * regions within list or map values as well (requires Aerospike server\n   * version >= 3.8).\n   *\n   * @param {string} bin - The name of the bin.\n   * @param {number} lng - Longitude of the point.\n   * @param {number} lat - Latitude of the point.\n   * @param {number} [indexType=Aerospike.indexType.DEFAULT] - One of {@link\n   * module:aerospike.indexType}, i.e. LIST or MAPVALUES.\n   * @returns {FilterPredicate} Filter predicate that can be passed to the {@link Client#query} command.\n   *\n   * @since v2.0\n   */\n  geoContainsPoint: geoContainsPointFilter\n}\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/lists.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n/**\n * @module aerospike/lists\n *\n * @description This module defines operations on the List data type. Create\n * list operations used by the {@link Client#operate} command.\n *\n * For more information, please refer to the\n * <a href=\"http://www.aerospike.com/docs/guide/cdt-list.html\">&uArr;Lists</a>\n * documentation in the Aerospike Feature Guide.\n *\n * #### List Index\n *\n * List operations support negative indexing.  If the index is negative, the\n * resolved index starts backwards from end of list.\n *\n * Index/Range examples:\n *\n *  - Index 0: First item in list.\n *  - Index 4: Fifth item in list.\n *  - Index -1: Last item in list.\n *  - Index -3: Third to last item in list.\n *  - Index 1 Count 2: Second and third items in list.\n *  - Index -3 Count 3: Last three items in list.\n *  - Index -5 Count 4: Range between fifth to last item to second to last item inclusive.\n *\n * If an index is out of bounds, a parameter error will be returned. If a range\n * is partially out of bounds, the valid part of the range will be returned.\n *\n * @see {@link Client#operate}\n */\n\nconst as = require('../build/Release/aerospike.node')\nconst opcodes = as.operations\n\n/**\n * @private\n */\nfunction ListOperation (op, bin) {\n  this.op = op\n  this.bin = bin\n}\n\nmodule.exports = {\n\n  /**\n   * Appends an element to the end of a list.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {any} value - The value to be appended.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const op = Aerospike.operator\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.append('tags', 'orange'),\n   *   op.read('tags')\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error, result) => {\n   *       if (error) throw error\n   *       console.log(result.tags) // => [ 'blue', 'yellow', 'pink', 'orange' ]\n   *       client.close()\n   *     })\n   *   })\n   * })\n   */\n  append: function append (bin, value) {\n    var op = new ListOperation(opcodes.LIST_APPEND, bin)\n    op.value = value\n    return op\n  },\n\n  /**\n   * Appends a list of elements to the end of a list.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {Array<any>} list - Array of elements to be appended.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const op = Aerospike.operator\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.appendItems('tags', ['orange', 'green']),\n   *   op.read('tags')\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error, result) => {\n   *       if (error) throw error\n   *       console.log(result.tags) // => [ 'blue', 'yellow', 'pink', 'orange', 'green' ]\n   *       client.close()\n   *     })\n   *   })\n   * })\n   */\n  appendItems: function appendItems (bin, list) {\n    var op = new ListOperation(opcodes.LIST_APPEND_ITEMS, bin)\n    op.list = list\n    return op\n  },\n\n  /**\n   * Inserts an element at the specified index.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {number} index - List index at which the new element should be inserted.\n   * @param {any} value - The value to be appended.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const op = Aerospike.operator\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.insert('tags', 2, 'orange'),\n   *   op.read('tags')\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error, result) => {\n   *       if (error) throw error\n   *       console.log(result.tags) // => [ 'blue', 'yellow', 'orange', 'pink' ]\n   *       client.close()\n   *     })\n   *   })\n   * })\n   */\n  insert: function insert (bin, index, value) {\n    var op = new ListOperation(opcodes.LIST_INSERT, bin)\n    op.index = index\n    op.value = value\n    return op\n  },\n\n  /**\n   * Inserts a list of element at the specified index.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {number} index - List index at which the new element should be inserted.\n   * @param {Array<any>} list - Array of elements to be appended.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const op = Aerospike.operator\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.insertItems('tags', 2, ['orange', 'green']),\n   *   op.read('tags')\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error, result) => {\n   *       if (error) throw error\n   *       console.log(result.tags) // => [ 'blue', 'yellow', 'orange', 'green', 'pink' ]\n   *       client.close()\n   *     })\n   *   })\n   * })\n   */\n  insertItems: function insertItems (bin, index, list) {\n    var op = new ListOperation(opcodes.LIST_INSERT_ITEMS, bin)\n    op.index = index\n    op.list = list\n    return op\n  },\n\n  /**\n   * Removes and returns the list element at the specified index.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {number} index - List index of the element to be removed.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const op = Aerospike.operator\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.pop('tags', 1)\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error, result) => {\n   *       if (error) throw error\n   *       console.log(result.tags) // => [ 'yellow' ]\n   *       client.get(key, (error, record) => {\n   *         if (error) throw error\n   *         console.log(record) // => { tags: [ 'blue', 'pink' ] }\n   *         client.close()\n   *       })\n   *     })\n   *   })\n   * })\n   */\n  pop: function pop (bin, index) {\n    var op = new ListOperation(opcodes.LIST_POP, bin)\n    op.index = index\n    return op\n  },\n\n  /**\n   * Removes and returns the list elements at the specified range.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {number} index - Index of the first element in the range.\n   * @param {number} [count] - Number of elements in the range; if not specified, the range extends to the end of the list.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.popRange('tags', 0, 2)\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error, result) => {\n   *       if (error) throw error\n   *       console.log(result.tags) // => [ 'blue', 'yellow' ]\n   *       client.get(key, (error, record) => {\n   *         if (error) throw error\n   *         console.log(record) // => { tags: [ 'pink' ] }\n   *         client.close()\n   *       })\n   *     })\n   *   })\n   * })\n   */\n  popRange: function popRange (bin, index, count) {\n    var op = new ListOperation(opcodes.LIST_POP_RANGE, bin)\n    op.index = index\n    op.count = count\n    return op\n  },\n\n  /**\n   * Removes the list element at the specified index.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {number} index - Index of the element to be removed\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.remove('tags', 1)\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error) => {\n   *       if (error) throw error\n   *       client.get(key, (error, record) => {\n   *         if (error) throw error\n   *         console.log(record) // => { tags: [ 'blue', 'pink' ] }\n   *         client.close()\n   *       })\n   *     })\n   *   })\n   * })\n   */\n  remove: function remove (bin, index) {\n    var op = new ListOperation(opcodes.LIST_REMOVE, bin)\n    op.index = index\n    return op\n  },\n\n  /**\n   * Removes the list elements at the specified range.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {number} index - Index of the first element in the range.\n   * @param {number} [count] - Number of elements in the range; if not specified, the range extends to the end of the list.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.removeRange('tags', 0, 2)\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error) => {\n   *       if (error) throw error\n   *       client.get(key, (error, record) => {\n   *         if (error) throw error\n   *         console.log(record) // => { tags: [ 'pink' ] }\n   *         client.close()\n   *       })\n   *     })\n   *   })\n   * })\n   */\n  removeRange: function removeRange (bin, index, count) {\n    var op = new ListOperation(opcodes.LIST_REMOVE_RANGE, bin)\n    op.index = index\n    op.count = count\n    return op\n  },\n\n  /**\n   * Removes all the elements from the list.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.clear('tags')\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error) => {\n   *       if (error) throw error\n   *       client.get(key, (error, record) => {\n   *         if (error) throw error\n   *         console.log(record) // => { tags: [ ] }\n   *         client.close()\n   *       })\n   *     })\n   *   })\n   * })\n   */\n  clear: function clear (bin) {\n    return new ListOperation(opcodes.LIST_CLEAR, bin)\n  },\n\n  /**\n   * Sets the list element at the specified index to a new value.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {number} index - Index of the element to be replaced.\n   * @param {any} value - The new value to assigned to the list element.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.set('tags', 1, 'green')\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error) => {\n   *       if (error) throw error\n   *       client.get(key, (error, record) => {\n   *         if (error) throw error\n   *         console.log(record) // => { tags: [ 'blue', 'green', 'pink' ] }\n   *         client.close()\n   *       })\n   *     })\n   *   })\n   * })\n   */\n  set: function set (bin, index, value) {\n    var op = new ListOperation(opcodes.LIST_SET, bin)\n    op.index = index\n    op.value = value\n    return op\n  },\n\n  /**\n   * Removes all list elements **not** within the specified range.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {number} index - Index of the first element in the range.\n   * @param {number} [count] - Number of elements in the range; if not specified, the range extends to the end of the list.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.trim('tags', 1, 1)\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error) => {\n   *       if (error) throw error\n   *       client.get(key, (error, record) => {\n   *         if (error) throw error\n   *         console.log(record) // => { tags: [ 'yellow' ] }\n   *         client.close()\n   *       })\n   *     })\n   *   })\n   * })\n   */\n  trim: function trim (bin, index, count) {\n    var op = new ListOperation(opcodes.LIST_TRIM, bin)\n    op.index = index\n    op.count = count\n    return op\n  },\n\n  /**\n   * Returns the list element at the specified index.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {number} index - Index of the element to be returned.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.get('tags', 0)\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error) => {\n   *       if (error) throw error\n   *       client.get(key, (error, record) => {\n   *         if (error) throw error\n   *         console.log(record) // => { tags: 'blue' }\n   *         client.close()\n   *       })\n   *     })\n   *   })\n   * })\n   */\n  get: function get (bin, index) {\n    var op = new ListOperation(opcodes.LIST_GET, bin)\n    op.index = index\n    return op\n  },\n\n  /**\n   * Returns the list element at the specified range.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @param {number} index - Index of the first element in the range.\n   * @param {number} [count] - Number of elements in the range; if not specified, the range extends to the end of the list.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.getRange('tags', 1)\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error) => {\n   *       if (error) throw error\n   *       client.get(key, (error, record) => {\n   *         if (error) throw error\n   *         console.log(record) // => { tags: [ 'yellow', 'pink' ] }\n   *         client.close()\n   *       })\n   *     })\n   *   })\n   * })\n   */\n  getRange: function getRange (bin, index, count) {\n    var op = new ListOperation(opcodes.LIST_GET_RANGE, bin)\n    op.index = index\n    op.count = count\n    return op\n  },\n\n// pending server-side support for list increment operation [AER-5149]\n//\n//  /**\n//   * Increments the value at the given list index and returns the final result.\n//   *\n//   * @param {string} bin - The name of the bin. The bin must contain a List value.\n//   * @param {number} index - Index of the list element to increment.\n//   * @param {number} value - Value to increment the element by.\n//   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n//   *\n//   * @since v2.4\n//   *\n//   * @example\n//   *\n//   * const Aerospike = require('aerospike')\n//   * const lists = Aerospike.lists\n//   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n//   *\n//   * var ops = [\n//   *   lists.increment('counters', 1, 3)\n//   * ]\n//   *\n//   * Aerospike.client().connect((error, client) => {\n//   *   if (error) throw error\n//   *   client.put(key, { counters: [1, 2, 3] }, (error) => {\n//   *     if (error) throw error\n//   *     client.operate(key, ops, (error, result) => {\n//   *       if (error) throw error\n//   *       console.log(result['counters']) => 5\n//   *       client.get(key, (error, record) => {\n//   *         if (error) throw error\n//   *         console.log(record) // => { counters: [1, 5, 3] }\n//   *         client.close()\n//   *       })\n//   *     })\n//   *   })\n//   * })\n//   */\n//  increment: function increment (bin, index, value) {\n//    var op = new ListOperation(opcodes.LIST_INCREMENT, bin)\n//    op.index = index\n//    op.value = value\n//    return op\n//  },\n\n  /**\n   * Returns the element count of the list\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a List value.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   *\n   * @example\n   *\n   * const Aerospike = require('aerospike')\n   * const lists = Aerospike.lists\n   * const key = new Aerospike.Key('test', 'demo', 'mykey1')\n   *\n   * var ops = [\n   *   lists.size('tags')\n   * ]\n   *\n   * Aerospike.client().connect((error, client) => {\n   *   if (error) throw error\n   *   client.put(key, { tags: ['blue', 'yellow', 'pink'] }, (error) => {\n   *     if (error) throw error\n   *     client.operate(key, ops, (error) => {\n   *       if (error) throw error\n   *       console.log(record) // => { tags: 3 }\n   *       client.close()\n   *     })\n   *   })\n   * })\n   */\n  size: function size (bin) {\n    return new ListOperation(opcodes.LIST_SIZE, bin)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/lib/maps.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n/**\n * @module aerospike/maps\n *\n * @description This module defines operations on the Sorted Map data type that\n * can be used with the {@link Client#operate} command. Operations on Sorted\n * Maps require Aerospike Server\n * <a href=\"http://www.aerospike.com/download/server/notes.html#3.8.4\">&uArr;version 3.8.4</a>\n * or later.\n *\n * For more information, please refer to the\n * <a href=\"http://www.aerospike.com/docs/guide/cdt-map.html\">&uArr;Maps</a>\n * documentation in the Aerospike Feature Guide.\n *\n * #### Sorted Maps\n *\n * The Map data type supports both unordered and ordered maps. Maps can be\n * ordered by key, or by key and value. By default, maps are unordered. The map\n * order is controlled through the map policy and can be set either when the\n * map is created through the {@link module:aerospike/maps.put|put} or {@link\n * module:aerospike/maps.putItems|putItems} operations or later on through the\n * {@link module:aerospike/maps.setPolicy|setPolicy} operation.\n *\n * All maps maintain an index and a rank. The index is the item offset from the\n * start of the map, for both unordered and ordered maps. The rank is the\n * sorted index of the value component. Map supports negative indexing for\n * index and rank.\n *\n * Index examples:\n *\n *  - Index 0: First item in map.\n *  - Index 4: Fifth item in map.\n *  - Index -1: Last item in map.\n *  - Index -3: Third to last item in map.\n *  - Index 1 Count 2: Second and third items in map.\n *  - Index -3 Count 3: Last three items in map.\n *  - Index -5 Count 4: Range between fifth to last item to second to last item inclusive.\n *\n * Rank examples:\n *\n *  - Rank 0: Item with lowest value rank in map.\n *  - Rank 4: Fifth lowest ranked item in map.\n *  - Rank -1: Item with highest ranked value in map.\n *  - Rank -3: Item with third highest ranked value in map.\n *  - Rank 1 Count 2: Second and third lowest ranked items in map.\n *  - Rank -3 Count 3: Top three ranked items in map.\n *\n * @see {@link Client#operate}\n *\n * @example\n *\n * const Aerospike = require('aerospike')\n * const maps = Aerospike.maps\n * const key = new Aerospike.Key('test', 'demo', 'key1')\n *\n * var keyOrderedPolicy = { order: maps.order.KEY_ORDERED }\n * var createOnlyPolicy = { writeMode: maps.writeMode.CREATE_ONLY }\n * var ops = [\n *   maps.put('map', 'e', 5, keyOrderedPolicy),                    // => { map: { e: 5 } }\n *   maps.putItems('map', { d: 4, b: 2, c: 3 }),                   // => { map: { b: 2, c: 3, d: 4, e: 5 } }\n *   maps.putItems('map', { c: 99, a: 1 }, createOnlyPolicy),      // => { map: { a: 1, b: 2, c: 3, d: 4, e: 5 } }\n *   maps.removeByValue('map', 3),                                 // => { map: { a: 1, b: 2, d: 4, e: 5 } }\n *   maps.removeByIndexRange('map', -2, 2, maps.returnType.KEY)    // => { map: { a: 1, b: 2 } }\n * ]\n *\n * Aerospike.connect((error, client) => {\n *   if (error) throw error\n *   client.operate(key, ops, (error, result) => {\n *     if (error) throw error\n *     console.log(result)                                         // => { map: ['d', 'e'] }\n *     client.get(key, (error, record) => {\n *       if (error) throw error\n *       console.log(record)                                       // => { map: { a: 1, b: 2 } }\n *       client.close()\n *     })\n *   })\n * })\n */\n\nconst as = require('../build/Release/aerospike.node')\nconst opcodes = as.operations\nconst utils = require('./utils')\n\n/**\n * @private\n */\nfunction MapOperation (op, bin) {\n  this.op = op\n  this.bin = bin\n}\n\nmodule.exports = {\n\n  /**\n   * @typedef {Object} module:aerospike/maps~MapPolicy\n   *\n   * A policy affecting the behavior of map operations.\n   *\n   * @property order - Sort order for the map. See {@link\n   * module:aerospike/maps.order} for possible values; default is\n   * <code>UNORDERED</code>.\n   *\n   * @property writeMode - Specifies the behavior when replacing or inserting\n   * map items. See {@link module:aerospike/maps.writeMode} for possible\n   * values; default is <code>UPDATE</code>.\n   */\n\n  /**\n   * Map order. The order determine what kind of index the Aerospike server\n   * maintains for the map.\n   *\n   * @member {Object} order\n   * @readonly\n   * @static\n   *\n   * @property UNORDERED - Map is not ordered. This is the default.\n   * @property KEY_ORDERED - Order map by key.\n   * @property KEY_VALUE_ORDERED - Order map by key, then value.\n   */\n\n  /**\n   * Map write mode. The write mode determines whether a write operation\n   * succeeds, depending on whether the map key(s) to be written already exist.\n   * It also determines whether a new map will be created automatically if the\n   * record bin, which the map operation is targeting, is currently empty.\n   *\n   * @member {Object} writeMode\n   * @readonly\n   * @static\n   *\n   * @property UPDATE - If the key already exists, the item will be\n   * overwritten. If the key does not exist, a new item will be created. This\n   * is the default write mode.\n   * @property UPDATE_ONLY - If the key already exists, the item will be\n   * overwritten. If the key does not exist, the write will fail.\n   * @property CREATE_ONLY - If the key already exists, the write will fail. If\n   * the key does not exist, a new item will be created.\n   */\n\n  /**\n   * Map return type. The return type determines what data of the selected\n   * items the get and remove operations return in the result of the {@link\n   * Client#operate} command. It is optional to specify the return type for\n   * remove operations; default is <code>NONE</code>. For get operations the\n   * return type parameter is required.\n   *\n   * @member {Object} returnType\n   * @readonly\n   * @static\n   *\n   * @property NONE - Do not return a result; this is the default.\n   * @property INDEX - Return key index order. (0 = first key, 1 = second key, ...)\n   * @property REVERSE_INDEX - Return reverse key order. (0 = last key, -1 = second last key, ...)\n   * @property RANK - Return value order. (0 = smallest value, 1 = second smallest value, ...)\n   * @property REVERSE_RANK - Return reverse value order. (0 = largest value, -1 = second largest value, ...)\n   * @property COUNT - Return count of items selected.\n   * @property KEY - Return key for single key read and key list for range read.\n   * @property VALUE - Return value for single key read and value list for range read.\n   * @property KEY_VALUE - Return map items keys and values as an Array, i.e. [key1, value1, key2, value2, ...].\n   */\n\n  /**\n   * Sets map policy attributes.\n   *\n   * This operation does not return any result.\n   *\n   * @param {string} bin - The name of the bin. The bin must contain a Map value.\n   * @param {module:aerospike/maps~MapPolicy} policy - The map policy.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  setPolicy: function setPolicy (bin, policy) {\n    var op = new MapOperation(opcodes.MAP_SET_POLICY, bin)\n    op.policy = policy\n    return op\n  },\n\n  /**\n   * Writes a key/value item to the map. Depending on the map policy and\n   * whether an entry with the same key already exists in the map, a new key\n   * will be added to the map or the existing entry with the same key will be\n   * updated. If the bin does not yet contain a map value, a new map may be created.\n   *\n   * This operation returns the new size of the map.\n   *\n   * @param {string} bin - The name of the bin. If the bin exists, it must\n   * contain a Map value; if it does not yet exist, a new Map may be created\n   * depending on the map policy's write mode.\n   * @param {any} key - Map key to write.\n   * @param {any} value - Map value to write.\n   * @param {module:aerospike/maps~MapPolicy} [policy] - The map policy.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  put: function put (bin, key, value, policy) {\n    var op = new MapOperation(opcodes.MAP_PUT, bin)\n    op.key = key\n    op.value = value\n    op.policy = policy\n    return op\n  },\n\n  /**\n   * Writes each entry of the given map to the map bin on the server. Depending\n   * on the map policy and whether an entry with the same key already exists in\n   * the map, a new entry will be added to the map or the existing entry with\n   * the same key will be updated. If the bin does not yet contain a map value,\n   * a new map may be created.\n   *\n   * This operation returns the new size of the map.\n   *\n   * @param {string} bin - The name of the bin. If the bin exists, it must\n   * contain a Map value; if it does not yet exist, a new Map may be created\n   * depending on the map policy's write mode.\n   * @param {object} items - One or more key value pairs to write to the map.\n   * @param {module:aerospike/maps~MapPolicy} [policy] - The map policy.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  putItems: function putItems (bin, items, policy) {\n    var op = new MapOperation(opcodes.MAP_PUT_ITEMS, bin)\n    op.items = items\n    op.policy = policy\n    return op\n  },\n\n  /**\n   * Increments the map entry identified by the given key by the value\n   * <code>incr</code>. Valid only for numeric values.\n   *\n   * If a map entry with the given key does not exist, the map policy's write\n   * mode determines whether a new entry will be created same as for the\n   * {@link module:aerospike/maps.put|put} command. This operation may create a\n   * new map if the map bin is currently empty.\n   *\n   * This operation returns the new value of the map entry.\n   *\n   * @param {string} bin - The name of the bin. If the bin exists, it must\n   * contain a Map value; if it does not yet exist, a new Map may be created\n   * depending on the map policy's write mode.\n   * @param {any} key - The map key.\n   * @param {number} incr - The value to increment the map entry by.\n   * @param {module:aerospike/maps~MapPolicy} [policy] - The map policy.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  increment: function increment (bin, key, incr, policy) {\n    var op = new MapOperation(opcodes.MAP_INCREMENT, bin)\n    op.key = key\n    op.incr = incr\n    op.policy = policy\n    return op\n  },\n\n  /**\n   * Decrements the map entry identified by the given key by the value\n   * <code>decr</code>. Valid only for numeric values.\n   *\n   * If a map entry with the given key does not exist, the map policy's write\n   * mode determines whether a new entry will be created same as for the\n   * {@link module:aerospike/maps.put|put} command. This operation may create a\n   * new map if the map bin is currently empty.\n   *\n   * This operation returns the new value of the map entry.\n   *\n   * @param {string} bin - The name of the bin. If the bin exists, it must\n   * contain a Map value; if it does not yet exist, a new Map may be created\n   * depending on the map policy's write mode.\n   * @param {any} key - The map key.\n   * @param {number} decr - The value to decrement the map entry by.\n   * @param {module:aerospike/maps~MapPolicy} [policy] - The map policy.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  decrement: function decrement (bin, key, decr, policy) {\n    var op = new MapOperation(opcodes.MAP_DECREMENT, bin)\n    op.key = key\n    op.decr = decr\n    op.policy = policy\n    return op\n  },\n\n  /**\n   * Removes all items in the map.\n   *\n   * This operation does not return any result.\n   *\n   * @param {string} bin - The name of the bin. If the bin exists, it must\n   * contain a Map value; if it does not yet exist, a new Map may be created\n   * depending on the map policy's write mode.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  clear: function clear (bin) {\n    return new MapOperation(opcodes.MAP_CLEAR, bin)\n  },\n\n  /**\n   * Removes a single item identified by key from the map.\n   *\n   * This operation returns the removed data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {any} key - The map key.\n   * @param {number} [returnType] - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  removeByKey: function removeByKey (bin, key, returnType) {\n    var op = new MapOperation(opcodes.MAP_REMOVE_BY_KEY, bin)\n    op.key = key\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Removes one or more items identified by key from the map.\n   *\n   * This operation returns the removed data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {Array<any>} keys - An array of map keys.\n   * @param {number} [returnType] - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  removeByKeyList: function removeByKeyList (bin, keys, returnType) {\n    var op = new MapOperation(opcodes.MAP_REMOVE_BY_KEY_LIST, bin)\n    op.keys = keys\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Removes one or more items identified by a range of keys from the map.\n   *\n   * This operation returns the removed data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {?any} begin - Start key in the range (inclusive). If set to\n   * <code>null</code>, the range includes all keys less than the\n   * <code>end</code> key.\n   * @param {?any} end - End key in the range (exclusive). If set to\n   * <code>null</code>, the range includes all keys greater than or equal to the\n   * <code>begin</code> key.\n   * @param {number} [returnType] - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  removeByKeyRange: function removeByKeyRange (bin, begin, end, returnType) {\n    var op = new MapOperation(opcodes.MAP_REMOVE_BY_KEY_RANGE, bin)\n    op.begin = begin\n    op.end = end\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Removes one or more items identified by a single value from the map.\n   *\n   * This operation returns the removed data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {any} value - The map value.\n   * @param {number} [returnType] - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  removeByValue: function removeByValue (bin, value, returnType) {\n    var op = new MapOperation(opcodes.MAP_REMOVE_BY_VALUE, bin)\n    op.value = value\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Removes one or more items identified by a list of values from the map.\n   *\n   * This operation returns the removed data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {Array<any>} values - An array of map values.\n   * @param {number} [returnType] - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  removeByValueList: function removeByValueList (bin, values, returnType) {\n    var op = new MapOperation(opcodes.MAP_REMOVE_BY_VALUE_LIST, bin)\n    op.values = values\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Removes one or more items identified by a range of values from the map.\n   *\n   * This operation returns the removed data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {?any} begin - Start values in the range (inclusive). If set to\n   * <code>null</code>, the range includes all values less than the\n   * <code>end</code> value.\n   * @param {?any} end - End value in the range (exclusive). If set to\n   * <code>null</code>, the range includes all values greater than or equal to the\n   * <code>begin</code> value.\n   * @param {number} [returnType] - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  removeByValueRange: function removeByValueRange (bin, begin, end, returnType) {\n    var op = new MapOperation(opcodes.MAP_REMOVE_BY_VALUE_RANGE, bin)\n    op.begin = begin\n    op.end = end\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Removes a single item identified by it's index value from the map.\n   *\n   * This operation returns the removed data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {number} index - Index of the entry to remove.\n   * @param {number} [returnType] - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  removeByIndex: function removeByIndex (bin, index, returnType) {\n    var op = new MapOperation(opcodes.MAP_REMOVE_BY_INDEX, bin)\n    op.index = index\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Removes one or more items in the specified index range from the map.\n   *\n   * This operation returns the removed data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {number} index - Starting index.\n   * @param {?number} count - Number of items to delete; if not specified, the\n   * range includes all items starting from <code>index</code>.\n   * @param {number} [returnType] - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  removeByIndexRange: function removeByIndexRange (bin, index, count, returnType) {\n    var op = new MapOperation(opcodes.MAP_REMOVE_BY_INDEX_RANGE, bin)\n    op.index = index\n    op.count = count\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Removes a single item identified by it's rank value from the map.\n   *\n   * This operation returns the removed data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {number} rank - Rank of the entry to remove.\n   * @param {number} [returnType] - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  removeByRank: function removeByRank (bin, rank, returnType) {\n    var op = new MapOperation(opcodes.MAP_REMOVE_BY_RANK, bin)\n    op.rank = rank\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Removes one or more items in the specified rank range from the map.\n   *\n   * This operation returns the removed data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {number} index - Starting rank.\n   * @param {?number} count - Number of items to delete; if not specified, the\n   * range includes all items starting from <code>rank</code>.\n   * @param {number} [returnType] - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  removeByRankRange: function removeByRankRange (bin, rank, count, returnType) {\n    var op = new MapOperation(opcodes.MAP_REMOVE_BY_RANK_RANGE, bin)\n    op.rank = rank\n    op.count = count\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Returns the size of the map.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  size: function size (bin) {\n    return new MapOperation(opcodes.MAP_SIZE, bin)\n  },\n\n  /**\n   * Retrieves a single item identified by key from the map.\n   *\n   * This operation returns the data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {any} key - The map key.\n   * @param {number} returnType - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  getByKey: function getByKey (bin, key, returnType) {\n    var op = new MapOperation(opcodes.MAP_GET_BY_KEY, bin)\n    op.key = key\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Retrieves one or more items identified by a range of keys from the map.\n   *\n   * This operation returns the data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {?any} begin - Start key in the range (inclusive). If set to\n   * <code>null</code>, the range includes all keys less than the\n   * <code>end</code> key.\n   * @param {?any} end - End key in the range (exclusive). If set to\n   * <code>null</code>, the range includes all keys greater than or equal to the\n   * <code>begin</code> key.\n   * @param {number} returnType - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  getByKeyRange: function getByKeyRange (bin, begin, end, returnType) {\n    var op = new MapOperation(opcodes.MAP_GET_BY_KEY_RANGE, bin)\n    op.begin = begin\n    op.end = end\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Retrieves one or more items identified by a single value from the map.\n   *\n   * This operation returns the data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {any} value - The map value.\n   * @param {number} returnType - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  getByValue: function getByValue (bin, value, returnType) {\n    var op = new MapOperation(opcodes.MAP_GET_BY_VALUE, bin)\n    op.value = value\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Retrieves one or more items identified by a range of values from the map.\n   *\n   * This operation returns the data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {?any} begin - Start values in the range (inclusive). If set to\n   * <code>null</code>, the range includes all values less than the\n   * <code>end</code> value.\n   * @param {?any} end - End value in the range (exclusive). If set to\n   * <code>null</code>, the range includes all values greater than or equal to the\n   * <code>begin</code> value.\n   * @param {number} returnType - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  getByValueRange: function getByValueRange (bin, begin, end, returnType) {\n    var op = new MapOperation(opcodes.MAP_GET_BY_VALUE_RANGE, bin)\n    op.begin = begin\n    op.end = end\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Retrieves a single item identified by it's index value from the map.\n   *\n   * This operation returns the data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {number} index - Index of the entry to remove.\n   * @param {number} returnType - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  getByIndex: function getByIndex (bin, index, returnType) {\n    var op = new MapOperation(opcodes.MAP_GET_BY_INDEX, bin)\n    op.index = index\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Retrieves one or more items in the specified index range from the map.\n   *\n   * This operation returns the data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {number} index - Starting index.\n   * @param {?number} count - Number of items to delete; if not specified, the\n   * range includes all items starting from <code>index</code>.\n   * @param {number} returnType - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  getByIndexRange: function getByIndexRange (bin, index, count, returnType) {\n    var op = new MapOperation(opcodes.MAP_GET_BY_INDEX_RANGE, bin)\n    op.index = index\n    op.count = count\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Retrieves a single item identified by it's rank value from the map.\n   *\n   * This operation returns the data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {number} rank - Rank of the entry to remove.\n   * @param {number} returnType - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  getByRank: function getByRank (bin, rank, returnType) {\n    var op = new MapOperation(opcodes.MAP_GET_BY_RANK, bin)\n    op.rank = rank\n    op.returnType = returnType\n    return op\n  },\n\n  /**\n   * Retrieves one or more items in the specified rank range from the map.\n   *\n   * This operation returns the data specified by <code>returnType</code>.\n   *\n   * @param {string} bin - The name of the bin, which must contain a Map value.\n   * @param {number} index - Starting rank.\n   * @param {?number} count - Number of items to delete; if not specified, the\n   * range includes all items starting from <code>rank</code>.\n   * @param {number} returnType - The return type indicating what data of the\n   * removed item(s) to return (if any); see {@link module:aerospike/maps.returnType} for possible values.\n   * @returns {Object} Operation that can be passed to the {@link Client#operate} command.\n   */\n  getByRankRange: function getByRankRange (bin, rank, count, returnType) {\n    var op = new MapOperation(opcodes.MAP_GET_BY_RANK_RANGE, bin)\n    op.rank = rank\n    op.count = count\n    op.returnType = returnType\n    return op\n  },\n\n  kvlistToMap: utils.kvlistToMap\n}\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/benchmarks/alerts.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nvar winston\nvar nodemailer\nvar transporter\n\nvar severity = {\n  HIGH: 0,\n  MEDIUM: 1,\n  LOW: 2\n}\n\nvar action = {\n  SENDEMAIL: 0,\n  PRINTCONSOLE: 1,\n  PRINTFILE: 2\n}\n\nvar mediumSevCount = 0\nvar lowSevCount = 0\n\n// setup winston logger to log it to file or console\n// Setup node mailers to generate email alerts to\n// send emails in case of errors.\nvar alertMode\nfunction setupAlertSystem (alert) {\n  if (alert.mode === 'EMAIL') {\n    nodemailer = require('nodemailer')\n    transporter = nodemailer.createTransport({\n      service: 'Gmail',\n      auth: {\n        user: 'gmail account',\n        pass: 'password'\n      }\n    })\n    alertMode = alert.mode\n  } else {\n    winston = require('winston')\n    if (alert.mode === 'FILE') {\n      winston.add(winston.transports.file, {filename: alert.filename})\n      winston.remove(winston.transports.Console)\n    }\n    alertMode = alert.mode\n  }\n}\n\nfunction handleAlert (alertInfo, sev) {\n  var generateAlert = false\n  switch (sev) {\n    case severity.HIGH:\n      generateAlert = true\n      break\n    case severity.MEDIUM:\n      mediumSevCount++\n      if (mediumSevCount % 3 === 0) {\n        generateAlert = true\n      }\n      break\n    case severity.LOW:\n      lowSevCount++\n      if (lowSevCount % 6 === 0) {\n        generateAlert = true\n      }\n      break\n    default:\n      // do nothing\n      break\n  }\n  if (generateAlert) {\n    if (alertMode === 'EMAIL') {\n      // send an email.\n      var email = {\n        from: 'Aerospike alert account',\n        to: 'gayathri@aerospike.com',\n        subject: 'Nodejs Longevity Alert',\n        text: JSON.stringify(alertInfo)\n      }\n      transporter.sendMail(email, function (error, info) {\n        if (error) {\n          console.log(error)\n        }\n      })\n    } else if (alertMode === 'FILE' || alertMode === 'CONSOLE') {\n      winston.info(alertInfo)\n    }\n  } else {\n    // should we store the temporary information in some structure.\n  }\n}\n\nmodule.exports = {\n  handleAlert: handleAlert,\n  setupAlertSystem: setupAlertSystem,\n  severity: severity,\n  action: action\n}\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/benchmarks/inspect.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n// *****************************************************************************\n// node inspect.js -h\n// *****************************************************************************\n\nvar spawn = require('child_process').spawn\n\nvar cluster = require('cluster')\nvar yargs = require('yargs')\nvar os = require('os')\nvar stats = require('./stats')\n\n// *****************************************************************************\n// Options Parsing\n// *****************************************************************************\n\nvar argp = yargs\n  .usage('$0 [options]')\n  .options({\n    help: {\n      boolean: true,\n      describe: 'Display this message.'\n    },\n    host: {\n      alias: 'h',\n      default: '127.0.0.1',\n      describe: 'Aerospike database address.'\n    },\n    port: {\n      alias: 'p',\n      default: 3000,\n      describe: 'Aerospike database port.'\n    },\n    timeout: {\n      alias: 't',\n      default: 10,\n      describe: 'Timeout in milliseconds.'\n    },\n    log: {\n      alias: 'l',\n      default: 1,\n      describe: 'Log level [0-5].'\n    },\n    namespace: {\n      alias: 'n',\n      default: 'test',\n      describe: 'Key namespace.'\n    },\n    set: {\n      alias: 's',\n      default: 'demo',\n      describe: 'Key set.'\n    },\n    reads: {\n      alias: 'R',\n      default: 1,\n      describe: 'The read in the read/write ratio.'\n    },\n    writes: {\n      alias: 'W',\n      default: 1,\n      describe: 'The write in the read/write ratio.'\n    },\n    keyrange: {\n      alias: 'K',\n      default: 1000,\n      describe: 'The number of keys to use.'\n    }\n  })\n\nvar argv = argp.argv\n\nif (argv.help === true) {\n  argp.showHelp()\n  process.exit()\n}\n\nif (!cluster.isMaster) {\n  console.error('main.js must not run as a child process.')\n  process.exit()\n}\n\n// *****************************************************************************\n// Globals\n// *****************************************************************************\n\nvar cpus = os.cpus()\n\nvar P_MIN = 1\nvar P_MAX = cpus.length\nvar P_STEP = 1\nvar I_MIN = 1\nvar I_MAX = 1\nvar I_STEP = 1\nvar O_MIN = 1\nvar O_MAX = 100\nvar O_STEP = 8\n\n// *****************************************************************************\n// Functions\n// *****************************************************************************\n\nvar results = []\nvar errors = []\n\nfunction reportStep (p, i, o, code, stdout, stderr) {\n  console.log('processes: %d, iterations: %d, operations: %d, status: %d', p, i, o, code)\n\n  console.log()\n\n  var result\n\n  if (code === 0) {\n    result = JSON.parse(stdout)\n\n    console.log('    tps (per process):')\n    console.log('        min: %d, max: %d, mean: %d',\n      result.tps.min,\n      result.tps.max,\n      result.tps.mean\n    )\n\n    console.log('    times (ms):')\n    console.log('        min: %d, max: %d, mean: %d',\n      result.times.min.toFixed(2),\n      result.times.max.toFixed(2),\n      result.times.mean.toFixed(2)\n    )\n\n    console.log('    duration:')\n    stats.print_histogram(result.durations, console.log, '    ')\n\n    console.log('    status codes:')\n    stats.print_histogram(result.status_codes, console.log, '    ')\n\n    results.push(result)\n  } else {\n    stderr.split('\\n').forEach(function (l) {\n      console.log('    error: %s', l)\n    })\n    errors.push([p, i, o, code, stderr])\n  }\n\n  console.log()\n}\n\nfunction reportFinal () {\n  console.log()\n  console.log('SUMMARY')\n  console.log()\n\n  var matched = results.filter(function (res) {\n    var ops = res.operations\n    return (res.durations['<= 1'] / ops * 100).toFixed(0) >= 90 &&\n    (res.durations['> 1'] / ops * 100).toFixed(0) <= 10 &&\n    (res.durations['> 2'] / ops * 100).toFixed(0) <= 2 &&\n    (res.durations['<= 1'] + res.durations['> 1'] + res.durations['> 2'] === ops)\n  })\n\n  matched.forEach(function (res) {\n    console.log('  processes: %d, iterations: %d, operations: %d',\n      res.configuration.processes,\n      res.configuration.iterations,\n      res.configuration.operations\n    )\n    console.log('      tps:  {min: %d, max: %d, avg: %d}',\n      res.tps.min,\n      res.tps.max,\n      res.tps.mean\n    )\n    console.log('      time: {min: %d, max: %d, avg: %d}',\n      res.times.min.toFixed(2),\n      res.times.max.toFixed(2),\n      res.times.mean.toFixed(2)\n    )\n    console.log('      duration:')\n    stats.print_histogram(res.durations, console.log, '      ')\n  })\n\n  var groupOps = {}\n\n  matched.forEach(function (res) {\n    var ops = res.configuration.operations\n    var group = (groupOps[ops] || [])\n    group.push(res)\n    groupOps[ops] = group\n  })\n\n  console.log()\n  console.log()\n  for (var k in groupOps) {\n    var ops = groupOps[k]\n    console.log('operations: %d', k)\n    for (var o = 0; o < ops.length; o++) {\n      var op = ops[o]\n      console.log('    p: %d, tps: {l: %d, u: %d, m: %d}, time: {l: %d, u: %d, m: %d}, dur: {0: %d, 1: %d, 2: %d}',\n        op.configuration.processes,\n        op.tps.min,\n        op.tps.max,\n        op.tps.mean,\n        op.times.min.toFixed(2),\n        op.times.max.toFixed(2),\n        op.times.mean.toFixed(2),\n        op.durations['<= 1'],\n        op.durations['> 1'],\n        op.durations['> 2']\n      )\n    }\n  }\n  console.log()\n\n  var opsHist = {}\n\n  matched.forEach(function (res) {\n    var ops = res.configuration.operations\n    opsHist[ops] = (opsHist[ops] || 0) + 1\n  })\n\n  console.log()\n  console.log('Number of Concurrent Transactions:')\n  stats.print_histogram(opsHist, console.log, '    ')\n\n  console.log()\n}\n\nfunction exec (p, i, o) {\n  var stdout = new Buffer('')\n  var stderr = new Buffer('')\n\n  var prog = 'node'\n\n  var args = ['main.js',\n    '-h', argv.host, '-p', argv.port, '-t', argv.timeout,\n    '-n', argv.namespace, '-s', argv.set,\n    '-R', argv.reads, '-W', argv.writes, '-K', argv.keyrange,\n    '-P', p, '-I', i, '-O', o,\n    '--silent', '--json'\n  ]\n\n  var proc = spawn(prog, args)\n\n  proc.stdout.on('data', function (data) {\n    stdout = Buffer.concat([stdout, data])\n  })\n\n  proc.stderr.on('data', function (data) {\n    stderr = Buffer.concat([stderr, data])\n  })\n\n  proc.on('close', function (code) {\n    reportStep(p, i, o, code, stdout.toString(), stderr.toString())\n    step(p, i, o)\n  })\n}\n\nfunction step (p, i, o) {\n  o += O_STEP\n\n  if (o > O_MAX) {\n    i += I_STEP\n    o = O_MIN\n  }\n\n  if (i > I_MAX) {\n    p += P_STEP\n    i = I_MIN\n    o = O_MIN\n  }\n\n  if (p > P_MAX) {\n    reportFinal()\n    return\n  }\n\n  return exec(p, i, o)\n}\n\nexec(P_MIN, I_MIN, O_MIN)\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/benchmarks/main.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n// *****************************************************************************\n// node -O 10000 -P 4 -R 0.5\n// *****************************************************************************\n\nvar aerospike = require('aerospike')\nvar cluster = require('cluster')\nvar winston = require('winston')\nvar stats = require('./stats')\nvar alerts = require('./alerts')\nvar argv = require('./config.json')\n\n// *****************************************************************************\n// Globals\n// *****************************************************************************\n\nvar OP_TYPES = 4 // READ, WRITE, SCAN and QUERY\nvar STATS = 3 // OPERATIONS, TIMEOUTS and ERRORS\n\nvar queryWorkers = 0\nvar scanWorkers = 0\nvar online = 0\nvar exited = 0\nvar rwOnline = 0\nvar queryOnline = 0\nvar scanOnline = 0\n\n//\n// Number of completed operations(READ & WRITE), timed out operations and operations that ran into error per second\n//\nvar intervalStats = new Array(OP_TYPES)\nresetIntervalStats()\n\nif (argv.querySpec !== undefined) {\n  queryWorkers = argv.querySpec.length\n}\n\nif (argv.scanSpec !== undefined) {\n  scanWorkers = argv.scanSpec.length\n}\n\nvar rwWorkers = argv.processes - queryWorkers - scanWorkers\n\nif (!cluster.isMaster) {\n  console.error('main.js must not run as a child process.')\n  process.exit()\n}\n\nvar FOPS = (argv.operations / (argv.reads + argv.writes))\nvar ROPS = FOPS * argv.reads\nvar WOPS = FOPS * argv.writes\nvar ROPSPCT = ROPS / argv.operations * 100\nvar WOPSPCT = WOPS / argv.operations * 100\n\nif ((ROPS + WOPS) < argv.operations) {\n  var DOPS = argv.operations - (ROPS + WOPS)\n  ROPS += DOPS\n}\n\nif (argv.time !== undefined) {\n  argv.time = stats.parseTimeToSecs(argv.time)\n  argv.iterations = undefined\n}\n\nvar alert = {mode: argv.alert, filename: argv.filename}\nalerts.setupAlertSystem(alert)\n\n// *****************************************************************************\n// Logging\n// *****************************************************************************\n\nvar logger = new (winston.Logger)({\n  transports: [\n    new (winston.transports.Console)({\n      level: 'info',\n      silent: false,\n      colorize: true\n    })\n  ]\n})\n\n// *****************************************************************************\n// Functions\n// *****************************************************************************\n\nfunction finalize () {\n  stats.stop()\n  if (argv.summary === true && rwWorkers > 0) {\n    return stats.reportFinal(argv, console.log)\n  }\n}\n\nfunction workerSpawn () {\n  var worker = cluster.fork()\n  worker.iteration = 0\n  worker.on('message', workerResults(worker))\n}\n\nfunction workerExit (worker) {\n  worker.send(['end'])\n}\n\nfunction workerShutdown () {\n  Object.keys(cluster.workers).forEach(function (id) {\n    workerExit(cluster.workers[id])\n  })\n}\n\n/**\n * Signal all workers asking for data on transactions\n */\nfunction workerProbe () {\n  Object.keys(cluster.workers).forEach(function (id) {\n    cluster.workers[id].send(['trans'])\n  })\n}\n\nfunction rwWorkerJob (worker) {\n  var option = {\n    namespace: argv.namespace,\n    set: argv.set,\n    keyRange: argv.keyRange,\n    rops: ROPS,\n    wops: WOPS,\n    binSpec: argv.binSpec\n  }\n  worker.iteration++\n  worker.send(['run', option])\n}\n\n// @to-do this worker has to create index and then issue a query request\n// once the index is created. After implementing the task completed API\n// this can be enhanced for that.\nfunction queryWorkerJob (worker, id) {\n  var stmt = {}\n  var queryConfig = argv.querySpec[id]\n  if (queryConfig.qtype === 'Range') {\n    stmt.filters = [aerospike.filter.range(queryConfig.bin, queryConfig.min, queryConfig.max)]\n  } else if (queryConfig.qtype === 'Equal') {\n    stmt.filters = [aerospike.filter.equal(queryConfig.bin, queryConfig.value)]\n  }\n\n  var options = {\n    namespace: argv.namespace,\n    set: argv.set,\n    statement: stmt\n  }\n  worker.send(['query', options])\n}\n\nfunction scanWorkerJob (worker) {\n  var options = {\n    namespace: argv.namespace,\n    set: argv.set,\n    statement: argv.scanSpec\n  }\n  worker.send(['query', options])\n}\n\n/**\n * Collects the data related to transactions and prints it once the data is recieved from all workers.\n * (called per second)\n */\nvar counter = 0 // Number of times workerResultsInterval is called\nfunction workerResultsInterval (worker, intervalWorkerStats) {\n  for (var i = 0; i < OP_TYPES; i++) {\n    for (var j = 0; j < STATS; j++) {\n      intervalStats[i][j] = intervalStats[i][j] + intervalWorkerStats[i][j]\n    }\n  }\n  if (++counter % argv.processes === 0) {\n    stats.interval({\n      'read': intervalStats[0],\n      'write': intervalStats[1],\n      'query': intervalStats[2],\n      'scan': intervalStats[3]\n    })\n    if (!argv.silent) {\n      printIntervalStats()\n    }\n  }\n}\n\nfunction printIntervalStats () {\n  if (rwWorkers > 0) {\n    logger.info('%s read(tps=%d timeouts=%d errors=%d) write(tps=%d timeouts=%d errors=%d) ',\n      new Date().toString(), intervalStats[0][0], intervalStats[0][1], intervalStats[0][2],\n      intervalStats[1][0], intervalStats[1][1], intervalStats[1][2])\n  }\n  if (queryWorkers) {\n    logger.info('%s query(records = %d timeouts = %d errors = %d)',\n      new Date().toString(), intervalStats[2][0], intervalStats[2][1], intervalStats[2][2])\n  }\n  if (scanWorkers) {\n    logger.info('%s scan(records = %d timeouts = %d errors = %d)',\n      new Date().toString(), intervalStats[3][0], intervalStats[3][1], intervalStats[3][2])\n  }\n}\n\nfunction workerResultsIteration (worker, opStats) {\n  stats.iteration(opStats)\n  if (argv.iterations === undefined || worker.iteration < argv.iterations || argv.time !== undefined) {\n    rwWorkerJob(worker)\n  } else {\n    workerExit(worker)\n  }\n}\n\nfunction workerResults (worker) {\n  return function (message) {\n    if (message[0] === 'stats') {\n      workerResultsIteration(worker, message[1])\n    } else if (message[0] === 'alert') {\n      alerts.handleAlert(message[1].alert, message[1].severity)\n    } else {\n      workerResultsInterval(worker, message[1])\n    }\n  }\n}\n\n/**\n*  * Print config information\n*   */\nvar keyrange = argv.keyRange.max - argv.keyRange.min\n\nif (!argv.silent) {\n  logger.info('namespace: ' + argv.namespace + ', set: ' + argv.set + ', worker processes: ' + argv.processes +\n    ', keys: ' + keyrange + ', read: ' + ROPSPCT + '%, write: ' + WOPSPCT + '%')\n}\n\n/**\n * Flush out the current intervalStats and probe the worker every second.\n */\nsetInterval(function () {\n  resetIntervalStats()\n  workerProbe(cluster)\n}, 1000)\n\n/**\n * Reset the value of internal_stats.\n */\nfunction resetIntervalStats () {\n  intervalStats = [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\n}\n\n// *****************************************************************************\n// Event Listeners\n// *****************************************************************************\n\nprocess.on('exit', function () {\n  logger.debug('Exiting.')\n  if (exited === online) {\n    return finalize()\n  }\n})\n\nprocess.on('SIGINT', function () {\n  logger.debug('Recevied SIGINT.')\n})\n\nprocess.on('SIGTERM', function () {\n  logger.debug('Received SIGTERM.')\n})\n\ncluster.on('online', function (worker) {\n  online++\n  if (rwOnline < rwWorkers) {\n    rwOnline++\n    rwWorkerJob(worker)\n  } else if (queryOnline < queryWorkers) {\n    queryWorkerJob(worker, queryOnline)\n    queryOnline++\n  } else if (scanOnline < scanWorkers) {\n    scanOnline++\n    scanWorkerJob(worker)\n  }\n})\n\ncluster.on('disconnect', function (worker, code, signal) {\n  logger.debug('[worker: %d] Disconnected.', worker.process.pid, code)\n})\n\ncluster.on('exit', function (worker, code, signal) {\n  if (code !== 0) {\n    // non-ok status code\n    logger.error('[worker: %d] Exited: %d', worker.process.pid, code)\n    process.exit(1)\n  } else {\n    logger.debug('[worker: %d] Exited: %d', worker.process.pid, code)\n    exited++\n  }\n  if (exited === online) {\n    process.exit(0)\n  }\n})\n\n// *****************************************************************************\n// Setup Workers\n// *****************************************************************************\n\nif (argv.time !== undefined) {\n  setTimeout(function () {\n    resetIntervalStats()\n    workerProbe(cluster)\n    workerShutdown(cluster)\n  }, argv.time * 1000)\n}\n\ncluster.setupMaster({\n  exec: 'worker.js',\n  silent: false\n})\n\nstats.start()\nfor (var p = 0; p < argv.processes; p++) {\n  workerSpawn()\n}\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/benchmarks/memory.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nvar Table = require('cli-table')\nvar yargs = require('yargs')\n\nvar MEM_MATCH = /(\\d+(\\.\\d+)?) MB/\n\nvar TABLE_CHARS = {\n  'top': '',\n  'top-mid': '',\n  'top-left': '',\n  'top-right': '',\n  'bottom': '',\n  'bottom-mid': '',\n  'bottom-left': '',\n  'bottom-right': '',\n  'left': '',\n  'left-mid': '',\n  'mid': '',\n  'mid-mid': '',\n  'right': '',\n  'right-mid': '',\n  'middle': ''\n}\n\nvar TABLE_STYLE = {\n  'padding-left': 4,\n  'padding-right': 0,\n  'head': ['blue'],\n  'border': ['grey'],\n  'compact': true\n}\n\nvar ITERATION_COUNT = 0\n\nvar memCnt = 0\nvar memMin\nvar memMax\nvar memRanges = []\n\n// *****************************************************************************\n// Options Parsing\n// *****************************************************************************\n\nvar argp = yargs\n  .usage('$0 [options]')\n  .options({\n    help: {\n      boolean: true,\n      describe: 'Display this message.'\n    },\n    factor: {\n      alias: 'f',\n      default: 1,\n      describe: 'Factor to filter by.'\n    },\n    start: {\n      alias: 's',\n      default: undefined,\n      describe: 'Start GC range.'\n    },\n    end: {\n      alias: 'e',\n      default: undefined,\n      describe: 'End GC range.'\n    }\n  })\n\nvar argv = argp.argv\n\nif (argv.help === true) {\n  argp.showHelp()\n  process.exit()\n}\n\n// *****************************************************************************\n// Functions\n// *****************************************************************************\n\nvar MEM_MAX_MB = 100\nvar MEM_BUCKETS = 100\n\nfunction memoryBar (minUsedMb, maxUsedMb) {\n  var minUsedLen = Math.floor(minUsedMb / MEM_MAX_MB * MEM_BUCKETS)\n  var minUsedBar = new Buffer(minUsedLen)\n  if (minUsedLen > 0) {\n    minUsedBar.fill(']')\n  }\n\n  var maxUsedLen = Math.floor(maxUsedMb / MEM_MAX_MB * MEM_BUCKETS)\n  var maxUsedBar = new Buffer(maxUsedLen - minUsedLen)\n  if (maxUsedLen > 0) {\n    maxUsedBar.fill(']')\n  }\n\n  return minUsedBar.toString().blue + maxUsedBar.toString().red\n}\n\nfunction report () {\n  var minhist = {}\n  var maxhist = {}\n  var stephist = {}\n\n  var rtable = new Table({\n    head: ['min', 'min diff', 'max', 'max diff', 'steps', 'size'],\n    chars: TABLE_CHARS,\n    style: TABLE_STYLE\n  })\n\n  var l\n\n  var unfiltered = memRanges\n\n  var filtered = unfiltered.filter(function (r, i) {\n    if (argv.factor && i % argv.factor !== 0) {\n      return false\n    }\n    if (argv.start && i < argv.start) {\n      return false\n    }\n    if (argv.end && i > argv.end) {\n      return false\n    }\n    return true\n  })\n\n  filtered.forEach(function (r, i) {\n    var minceil = Math.ceil(r[0])\n    minhist[minceil] = (minhist[minceil] || 0) + 1\n\n    var maxceil = Math.ceil(r[1])\n    maxhist[maxceil] = (maxhist[maxceil] || 0) + 1\n\n    var step = Math.ceil(r[2])\n    stephist[step] = (stephist[step] || 0) + 1\n\n    if (l) {\n      rtable.push([\n        r[0],\n        (r[0] - l[0]).toFixed(3),\n        r[1],\n        (r[1] - l[1]).toFixed(3),\n        r[2],\n        (r[1] - r[0]).toFixed(3),\n        memoryBar(r[0], r[1])\n      ])\n    } else {\n      rtable.push([\n        r[0],\n        0.00,\n        r[1],\n        0.00,\n        r[2],\n        (r[1] - r[0]).toFixed(3),\n        memoryBar(r[0], r[1])\n      ])\n    }\n    l = r\n  })\n\n  var k\n\n  var minhead = []\n  var minbody = []\n  for (k in minhist) {\n    minhead.push('<' + k)\n    minbody.push(minhist[k])\n  }\n  var mintable = new Table({\n    head: minhead,\n    chars: TABLE_CHARS,\n    style: TABLE_STYLE\n  })\n  mintable.push(minbody)\n\n  var maxhead = []\n  var maxbody = []\n  for (k in maxhist) {\n    maxhead.push('<' + k)\n    maxbody.push(maxhist[k])\n  }\n  var maxtable = new Table({\n    head: maxhead,\n    chars: TABLE_CHARS,\n    style: TABLE_STYLE\n  })\n  maxtable.push(maxbody)\n\n  var stephead = []\n  var stepbody = []\n  for (k in stephist) {\n    stephead.push(k)\n    stepbody.push(stephist[k])\n  }\n  var steptable = new Table({\n    head: stephead,\n    chars: TABLE_CHARS,\n    style: TABLE_STYLE\n  })\n  steptable.push(stepbody)\n\n// *****************************************************************************\n\n  console.log()\n  console.log('Heap Usage (MB)'.grey)\n  rtable.toString().split('\\n').forEach(function (l) {\n    if (l.length > 0) {\n      console.log(l)\n    }\n  })\n\n  console.log()\n  console.log('Heap Used Lower Bound (MB)'.grey)\n  mintable.toString().split('\\n').forEach(function (l) {\n    if (l.length > 0) {\n      console.log(l)\n    }\n  })\n\n  console.log()\n  console.log('Heap Used Upper Bound (MB)'.grey)\n  maxtable.toString().split('\\n').forEach(function (l) {\n    if (l.length > 0) {\n      console.log(l)\n    }\n  })\n\n  console.log()\n  console.log('Iterations / GC'.grey)\n  steptable.toString().split('\\n').forEach(function (l) {\n    if (l.length > 0) {\n      console.log(l)\n    }\n  })\n\n  console.log()\n  console.log('%s %d', 'Number of Iterations:'.grey, ITERATION_COUNT)\n  console.log('%s %d', 'Number of GC executions (unfiltered):'.grey, unfiltered.length)\n  console.log('%s %d', 'Number of GC executions (filtered):'.grey, filtered.length)\n\n  console.log()\n}\n\nfunction readline (line) {\n  if (line.trim().length === 0) {\n    return line\n  }\n\n  var matches = line.match(MEM_MATCH)\n  if (!matches || !matches[1]) {\n    console.error('RegEx match failed on: |%s|', line, matches)\n    process.exit(1)\n  }\n\n  var mem = parseFloat(matches[1])\n\n  if (memMin === undefined) {\n    memMin = mem\n    memCnt = 0\n  }\n\n  if (memMax === undefined || mem > memMax) {\n    memMax = mem\n    memCnt++\n  } else {\n    // this is where the magic happens\n\n    // we will filter based on a factor\n    memRanges.push([memMin, memMax, memCnt])\n\n    // reset\n    memMin = mem\n    memMax = mem\n    memCnt = 0\n  }\n\n  ITERATION_COUNT++\n}\n\n// *****************************************************************************\n// Event Listeners\n// *****************************************************************************\n\nvar lastLine\n\nprocess.stdin.on('data', function (chunk) {\n  var i = 0\n  var j = 0\n\n  for (i = 0, j = chunk.indexOf('\\n', i); j !== -1; i = j + 1, j = chunk.indexOf('\\n', i)) {\n    if (lastLine) {\n      readline(lastLine + chunk.slice(i, j))\n      lastLine = undefined\n    } else {\n      readline(chunk.slice(i, j))\n    }\n  }\n\n  if (chunk.length > i) {\n    lastLine = chunk.slice(i)\n  }\n})\n\nprocess.stdin.on('end', function () {\n  report()\n})\n\n// *****************************************************************************\n// Run\n// *****************************************************************************\n\nprocess.stdin.resume()\nprocess.stdin.setEncoding('utf8')\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/benchmarks/stats.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\nvar Table = require('cli-table')\n\nconst OPERATION_STATUS = 0\nconst OPERATION_TIME_START = 1\nconst OPERATION_TIME_END = 2\n\n// histograms\n// 1. For status code of each operation.\n// 2. Latency histogram.\nvar hist = {}\nvar timeHist = {\n  '<= 1': 0,\n  '> 1': 0,\n  '> 2': 0,\n  '> 4': 0,\n  '> 8': 0,\n  '> 16': 0,\n  '> 32': 0\n}\n\nvar trans = { total: { count: 0, min_tps: Infinity, max_tps: 0 } }\n\nvar startTime\nvar totalDuration\n\nconst TABLE_CHARS = {\n  'top': '',\n  'top-mid': '',\n  'top-left': '',\n  'top-right': '',\n  'bottom': '',\n  'bottom-mid': '',\n  'bottom-left': '',\n  'bottom-right': '',\n  'left': '',\n  'left-mid': '',\n  'mid': '',\n  'mid-mid': '',\n  'right': '',\n  'right-mid': '',\n  'middle': ''\n}\n\nconst TABLE_STYLE = {\n  'padding-left': 4,\n  'padding-right': 0,\n  'head': ['blue'],\n  'border': ['grey'],\n  'compact': true\n}\n\nfunction sum (l, r) {\n  return l + r\n}\n\nfunction duration (start, end) {\n  var s = (end[0] - start[0]) * 1000000000\n  var ns = s + end[1] - start[1]\n  var ms = ns / 1000000\n  return ms\n}\n\nfunction parseTimeToSecs (time) {\n  if (time !== undefined) {\n    var timeMatch = time.toString().match(/(\\d+)([smh])?/)\n    if (timeMatch !== null) {\n      if (timeMatch[2] !== null) {\n        time = parseInt(timeMatch[1], 10)\n        var timeUnit = timeMatch[2]\n        switch (timeUnit) {\n          case 'm':\n            time = time * 60\n            break\n          case 'h':\n            time = time * 60 * 60\n            break\n        }\n      }\n    }\n  }\n  return time\n}\n\nfunction timeHistogram (operations) {\n  operations.map(function (op) {\n    return duration(op[OPERATION_TIME_START], op[OPERATION_TIME_END])\n  }).forEach(function (dur) {\n    var d = Math.floor(dur)\n    if (d > 32) {\n      timeHist['> 32']++\n    }\n    if (d > 16) {\n      timeHist['> 16']++\n    } else if (d > 8) {\n      timeHist['> 8']++\n    } else if (d > 4) {\n      timeHist['> 4']++\n    } else if (d > 2) {\n      timeHist['> 2']++\n    } else if (d > 1) {\n      timeHist['> 1']++\n    } else {\n      timeHist['<= 1']++\n    }\n  })\n}\n\nfunction numberFormat (v, precision) {\n  return v.toFixed(precision || 0).toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n}\n\nfunction timeUnits (v) {\n  var u = v === 1 ? 'second' : 'seconds'\n\n  if (Math.abs(v) >= 60) {\n    v = v / 60\n    u = v === 1 ? 'minute' : 'minutes'\n  }\n\n  if (Math.abs(v) >= 60) {\n    v = v / 60\n    u = v === 1 ? 'hour' : 'hours'\n  }\n\n  return numberFormat(v, 2) + ' ' + u\n}\n\nfunction calculateTPS (transactions) {\n  var seconds = totalDuration / 1000\n  Object.keys(transactions).forEach(function (stat) {\n    transactions[stat]['tps'] = transactions[stat]['count'] / seconds\n  })\n}\n\nfunction statusHistogram (operations) {\n  operations.map(function (op) {\n    return op[OPERATION_STATUS]\n  }).forEach(function (status) {\n    hist[status] = (hist[status] || 0) + 1\n  })\n}\n\nfunction printTable (table, print, prefix) {\n  table.toString().split('\\n').forEach(function (l) {\n    if (l.length > 0) {\n      print((prefix || '') + l)\n    }\n  })\n}\n\nfunction printEnvTable (print, prefix) {\n  var envTable = new Table({\n    chars: TABLE_CHARS,\n    style: TABLE_STYLE\n  })\n\n  envTable.push({'Node.js Version': process.versions.node})\n  envTable.push({'UV_THREADPOOL_SIZE': process.env.UV_THREADPOOL_SIZE || '-'})\n\n  printTable(envTable, print, prefix)\n}\n\nfunction printConfigTable (config, print, prefix) {\n  var configTable = new Table({\n    chars: TABLE_CHARS,\n    style: TABLE_STYLE\n  })\n\n  configTable.push({'operations': config.operations})\n  configTable.push({'iterations': config.iterations === undefined ? 'undefined' : config.iterations})\n  configTable.push({'processes': config.processes})\n  configTable.push({'time': config.time === undefined ? 'undefined' : timeUnits(config.time)})\n\n  printTable(configTable, print, prefix)\n}\n\nfunction printTransactions (transactions, print, prefix) {\n  var thead = []\n  thead.push('')\n  for (var t in transactions) {\n    thead.push(t)\n  }\n\n  var table = new Table({\n    head: thead,\n    chars: TABLE_CHARS,\n    style: TABLE_STYLE\n  })\n  var columns = Object.keys(transactions)\n\n  var row = columns.map(function (col) {\n    return numberFormat(transactions[col]['count'], 0)\n  })\n  table.push({'Total': row})\n\n  row = columns.map(function (col) {\n    return numberFormat(transactions[col]['tps'], 0)\n  })\n  table.push({'TPS': row})\n\n  row = columns.map(function (col) {\n    return numberFormat(transactions[col]['min_tps'], 0)\n  })\n  table.push({'Min TPS': row})\n\n  row = columns.map(function (col) {\n    return numberFormat(transactions[col]['max_tps'], 0)\n  })\n  table.push({'Max TPS': row})\n\n  printTable(table, print, prefix)\n}\n\nfunction printHistogram (histogram, print, prefix) {\n  var total = Object.keys(histogram).map(function (k) {\n    return histogram[k]\n  }).reduce(sum)\n\n  var thead = []\n  var tbody = []\n\n  for (var k in histogram) {\n    thead.push(k)\n    tbody.push(numberFormat(histogram[k] / total * 100, 1) + '%')\n  }\n\n  var table = new Table({\n    head: thead,\n    chars: TABLE_CHARS,\n    style: TABLE_STYLE\n  })\n\n  table.push(tbody)\n\n  printTable(table, print, prefix)\n}\n\nfunction start () {\n  startTime = process.hrtime()\n}\n\nfunction stop () {\n  var endTime = process.hrtime()\n  totalDuration = duration(startTime, endTime)\n}\n\nfunction iteration (operations) {\n  statusHistogram(operations)\n  timeHistogram(operations)\n}\n\nfunction aggregateIntervalStats (statName, tx) {\n  var stats = trans[statName] = trans[statName] || { count: 0, max_tps: 0, min_tps: Infinity }\n  stats['count'] += tx\n  if (tx > stats['max_tps']) stats['max_tps'] = tx\n  if (tx < stats['min_tps']) stats['min_tps'] = tx\n}\n\nfunction interval (intervalStats) {\n  var totalTX = 0\n  for (var stat in intervalStats) {\n    var tx = intervalStats[stat][0]\n    totalTX += tx\n    aggregateIntervalStats(stat, tx)\n  }\n  aggregateIntervalStats('total', totalTX)\n}\n\nfunction reportFinal (argv, print) {\n  calculateTPS(trans)\n  if (!argv.json) {\n    print()\n    print('SUMMARY')\n    print()\n    print('  Environment')\n    printEnvTable(print)\n    print()\n    print('  Configuration')\n    printConfigTable(argv, print)\n    print()\n    print('  Transactions')\n    printTransactions(trans, print)\n    print()\n    print('  Durations')\n    printHistogram(timeHist, print)\n    print()\n    print('  Status Codes')\n    printHistogram(hist, print)\n    print()\n  } else {\n    var output = {\n      env: {\n        nodejs: process.versions.node,\n        'UV_THREADPOOL_SIZE': process.env.UV_THREADPOOL_SIZE || null\n      },\n      configuration: {\n        operations: argv.operations,\n        iterations: argv.iterations,\n        processes: argv.processes\n      },\n      duration: totalDuration,\n      transactions: trans,\n      durations: timeHist,\n      status_codes: hist\n    }\n    console.log('%j', output)\n  }\n\n  return 0\n}\n\nmodule.exports = {\n  start: start,\n  stop: stop,\n  iteration: iteration,\n  interval: interval,\n  printHistogram: printHistogram,\n  reportFinal: reportFinal,\n  parseTimeToSecs: parseTimeToSecs\n}\n","/home/travis/build/npmtest/node-npmtest-aerospike/node_modules/aerospike/benchmarks/worker.js":"// *****************************************************************************\n// Copyright 2013-2017 Aerospike, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\")\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// *****************************************************************************\n\n// *****************************************************************************\n// Benchmark Worker, run operations and report results.\n// *****************************************************************************\n\nvar aerospike = require('aerospike')\nvar cluster = require('cluster')\nvar util = require('util')\nvar winston = require('winston')\nvar stats = require('./stats')\nvar status = aerospike.status\nvar alerts = require('./alerts.js')\nvar argv = require('./config.json')\n\n// *****************************************************************************\n//  MACROS\n// *****************************************************************************\n\nvar OP_TYPES = 4 // READ, WRITE, QUERY and SCAN\nvar READ = 0\nvar WRITE = 1\nvar QUERY = 2\nvar SCAN = 3\nvar TPS = 0\nvar TIMEOUT = 1\nvar ERROR = 2\n\nif (!cluster.isWorker) {\n  console.error('worker.js must only be run as a child process of main.js.')\n  process.exit()\n}\n\nargv.ttl = stats.parseTimeToSecs(argv.ttl)\n\n// variables to track memory growth(RSS) of worker process.\nvar heapMemory = 0\nvar initialFlux = true\nvar memGrowth = 0\nvar FLUX_PERIOD = 5\n\n// *****************************************************************************\n// Logging\n// *****************************************************************************\n\nvar logger = new (winston.Logger)({\n  transports: [\n    new (winston.transports.Console)({\n      level: 'info',\n      silent: false,\n      colorize: true\n    })\n  ]\n})\n\n// *****************************************************************************\n// Aerospike Client\n// *****************************************************************************\n\nvar config = {\n  policies: {\n    timeout: argv.timeout\n  },\n  sharedMemory: {\n    key: 0xA5000000,\n    maxNodes: 16,\n    maxNamespaces: 8,\n    takeoverThresholdSeconds: 30\n  }\n}\n\nif (argv.host) {\n  config.hosts = [{addr: argv.host, port: argv.port || 3000}]\n}\n\nif (argv.user !== null) {\n  config.user = argv.user\n}\n\nif (argv.password !== null) {\n  config.password = argv.password\n}\n\nvar client = aerospike.client(config)\n\nclient.connect(function (err) {\n  if (err) {\n    logger.error('Aerospike server connection error: ', err)\n    process.exit(1)\n  } else {\n    logger.info('worker connected: ' + client.config.hosts)\n  }\n})\n\n// *****************************************************************************\n// Operations\n// *****************************************************************************\n/**\n* key are in range [min ... max]\n*/\nfunction keygen (min, max) {\n  var rand = Math.floor(Math.random() * 0x100000000) % (max - min + 1) + min\n  return rand < 1 ? 1 : rand\n}\n\nvar STRING_DATA = 'This the test data to be written to the server'\n/**\n* Generate a record with string and blob in it if run for longevity.\n* Size of strings and blob is argv.datasize ( default 1K).\n*\n*\n*/\nfunction recordgen (key, binSpec) {\n  var data = {}\n  var i = 0\n  do {\n    var bin = binSpec[i]\n    switch (bin.type) {\n      case 'INTEGER':\n        data[bin.name] = key\n        break\n      case 'STRING':\n        data[bin.name] = STRING_DATA\n        while (data[bin.name].length < bin.size) {\n          data[bin.name] += STRING_DATA\n        }\n        data[bin.name] += key\n        break\n      case 'BYTES':\n        var bufData = STRING_DATA\n        while (bufData.length < bin.size) {\n          bufData += STRING_DATA\n        }\n        data[bin.name] = new Buffer(bufData)\n        break\n      default:\n        data.num = key\n        break\n    }\n    i++\n  } while (i < binSpec.length)\n  return data\n}\n\nfunction get (key, done) {\n  var timeStart = process.hrtime()\n  client.get(key, function (_error, _record, _metadata, _key) {\n    var timeEnd = process.hrtime()\n    var status = (_error && _error.code) || 0\n    done(status, timeStart, timeEnd, READ)\n  })\n}\n\n// set the ttl for the write\nvar metadata = {\n  ttl: argv.ttl\n}\n\nfunction put (options, done) {\n  var timeStart = process.hrtime()\n  client.put(options.key, options.record, metadata, function (_error, _record, _metadata, _key) {\n    var timeEnd = process.hrtime()\n    var status = (_error && _error.code) || 0\n    done(status, timeStart, timeEnd, WRITE)\n  })\n}\n\n// Structure to store per second statistics.\nvar intervalData = new Array(OP_TYPES)\nresetIntervalData()\n\nfunction run (options) {\n  var expected = options.rops + options.wops\n  var completed = 0\n\n  // @ TO-DO optimization.\n  // Currently stats of all the operations is collected and sent to\n  // master at the end of an iteration.\n  // Master puts the stats in appropriate histogram.\n  // Consider having histogram for each worker Vs sending the\n  // results in an array - Which one is more memory efficient.\n  var operations = Array(expected)\n  var readOps = options.rops\n  var writeOps = options.wops\n\n  function done (opStatus, opTimeStart, opTimeEnd, opType) {\n    operations[completed] = [opStatus, opTimeStart, opTimeEnd]\n    intervalData[opType][TPS]++\n    if (opStatus === status.AEROSPIKE_ERR_TIMEOUT) {\n      intervalData[opType][TIMEOUT]++\n    } else if (opStatus !== status.AEROSPIKE_OK && opStatus !== status.AEROSPIKE_ERR_TIMEOUT) {\n      intervalData[opType][ERROR]++\n    }\n\n    completed++\n\n    if (completed >= expected) {\n      process.send(['stats', operations])\n    }\n  }\n\n  while (writeOps > 0 || readOps > 0) {\n    var k = keygen(options.keyRange.min, options.keyRange.max)\n    var key = {ns: options.namespace, set: options.set, key: k}\n    var record = recordgen(k, options.binSpec)\n    var ops = {key: key, record: record}\n    if (writeOps > 0) {\n      writeOps--\n      put(ops, done)\n    }\n    if (readOps > 0) {\n      readOps--\n      get(key, done)\n    }\n  }\n}\n\n/*\n * Sends the populated intervalData to the parent and resets it for the next second\n */\nfunction respond () {\n  process.send(['trans', intervalData])\n  resetIntervalData()\n}\n\n/*\n * Reset intervalData\n */\nfunction resetIntervalData () {\n  intervalData[READ] = [0, 0, 0] // [reads_performed, reads_timeout, reads_error]\n  intervalData[WRITE] = [0, 0, 0] // [writes_performed, writes_timeout, writes_error]\n  intervalData[QUERY] = [0, 0, 0] // [QueryRecords, query_timeout, query_error]\n  intervalData[SCAN] = [0, 0, 0]\n}\n\n/*\n * Execute the long running job.\n */\n\nfunction executeJob (options, opType, callback) {\n  var job = client.query(options.namespace, options.set, options.statement)\n  var stream = job.execute()\n  stream.on('data', function (record) {\n    // count the records returned\n    intervalData[opType][TPS]++\n  })\n  stream.on('error', function (error) {\n    intervalData[opType][ERROR]++\n    if (error.code === status.AEROSPIKE_ERR_TIMEOUT) {\n      intervalData[opType][TIMEOUT]++\n    }\n  })\n  stream.on('end', function () {\n    // update a stat for number of jobs completed.\n    callback(options)\n  })\n}\n\nvar runLongRunningJob = function (options) {\n  if (options.statement.filters === undefined) {\n    executeJob(options, SCAN, runLongRunningJob)\n  } else {\n    executeJob(options, QUERY, runLongRunningJob)\n  }\n}\n\nvar monitorMemory = function () {\n  var currentMemory = process.memoryUsage()\n  currentMemory.pid = process.pid\n  if (heapMemory < currentMemory.heapUsed) {\n    memGrowth++\n    if (!initialFlux && memGrowth >= FLUX_PERIOD) {\n      var alertData = {\n        alert: currentMemory,\n        severity: alerts.severity.HIGH\n      }\n      memGrowth = 0\n      process.send(['alert', alertData])\n    } else if (initialFlux && memGrowth >= FLUX_PERIOD) {\n      initialFlux = false\n      memGrowth = 0\n    }\n  }\n  heapMemory = currentMemory.heapUsed\n}\n// log the memory footprint of the process every 10 minutes.\n// when it is run in longevity mode.\nif (argv.longevity) {\n  setInterval(monitorMemory, 6000)\n}\n// *****************************************************************************\n// Event Listeners\n// *****************************************************************************\n\n//\n// Listen for exit signal from parent. Hopefully we can do a clean\n// shutdown and emit results.\n//\nprocess.on('exit', function () {\n  logger.debug('Exiting.')\n})\n\nprocess.on('SIGINT', function () {\n  logger.debug('Received SIGINT.')\n  process.exit(0)\n})\n\nprocess.on('SIGTERM', function () {\n  logger.debug('Received SIGTERM.')\n  process.exit(0)\n})\n\n/**\n * Listen for messages from the parent. This is useful, if the parent\n * wants to run the child for a duration of time, rather than a\n * number of operations.\n *\n *  KEY         := STRING | INTEGER\n *  PUT         := '[' \"put\" ',' KEY ',' RECORD ']'\n *  GET         := '[' \"get\" ',' KEY ']'\n *  OPERATION   := GET | PUT\n *  OPERATIONS  := '[' OPERATION+ ']'\n *  COMMAND     := \"run\" ',' OPERATIONS\n *\n *  MESSAGE     := '[' COMMAND ']'\n */\nprocess.on('message', function (msg) {\n  logger.debug('command: ', util.inspect(msg[0]))\n  switch (msg[0]) {\n    case 'run':\n      return run(msg[1])\n    case 'query':\n      return runLongRunningJob(msg[1])\n    case 'trans':\n      return respond()\n    default:\n      return process.exit(0)\n  }\n})\n"}